.. Kenneth Lee 版权所有 2022

:Authors: Kenneth Lee
:Version: 0.1
:Date: 2022-08-30
:Status: Draft

C++编程入门4：调试
******************

正文
====

开始看这一章的时候，我预计你已经可以写一些程序了。那我也就开始预期你有调试的需
要了。

我们上一章说过，程序本质上是一个线程的顺序变化过程。那这每步的变化是什么样的，
我怎么知道呢？最好是走一步，停下来，让我看看内存里面的那些数变成多少，再走一步，
又停下来，再让我看看内存里面的数变成多少了。

这样我们就知道程序哪里写错了。

更高级一点的，我们也没有时间每次看一步，我们可以走到某个变量变成某个值的时候再
开始看，或者跑到某条指令上的时候再开始看。这些手段和行为，就称为“调试”。

其实调试用起来还是用Word那样的图形界面最好，这会比较容易看，但学习我觉得还是先
学最基本的命令行比较好，因为这样你会对自己在干什么有比较清楚的了解，有了这个基
础，到时学图形界面（叫IDE，Integrated Development Environment）就很简单了，基本
上看见就会用。

g++配套的调试器叫gdb，gnu debugger。如果你要深入学，我建议直接看它的手册：

`Debugging with GDB <https://sourceware.org/gdb/current/onlinedocs/gdb/>`_

但你也可以直接直接从我这里学习最基本的方法，其他东西等你熟悉以后再学。

你写好一个程序，比如my_app，要运行它，你在命令行上敲：::

  ./my_app

如果你要调试它，你需要敲：::

  gdb ./my_app

这样会用gdb来运行你的my_app，就可以用各种手段来一步步运行和检查它了。

但在这之前，我们要检查一下你的程序里面是不是带有调试信息。还记得第二章我们说编
译方法的时候的命令吗？：::

  g++ -Wall -g my_application.cc my_function.cc -o my_app

你需要保证你带了这个-g，如果没有-g，gdb其实也能够用，但因为g++编译的时候没有留
下变量放在哪里啦，函数叫什么名字啦，这些信息，有很多东西都查不到。我们一开始学
就不玩这些高难度的动作了，所以，要确认你的程序是带着-g的。

然后就可以运行上面的命令了。

gdb用起来和其他命令行一样的（比如你原来学习的Python），进入gdb后，你就进入gdb的命
令行。这时你的my_app还没有运行。

要运行它，你可以用run命令：::

  (gdb) run

这会一路运行你的程序，直到结束。这和不调试没有区别。你可以再运行run，再跑一次。
这是最基本的用法。

quit命令用于退出：::

  (gdb) quit

现在我们开始看调试，假定我们调试之前的这个程序：

.. code-block:c
  :linenos:

  void test_sum(void) {
    int sum = 0;
    for (int i = 0; i < 100; i++) {
            sum += i;
    }
    printf("sum = %d\n", sum);
  }
  
  int main(void)
  {
    test_sum();
    return 0;
  }

我们从头开始，让这个程序在main这个地方先停下来。我们用这个命令：::

  (gdb) break main

这是在main这个位置设置一个“断点”，这时你再运行run，gdb就会让这个程序停在这个位
置了：::

  (gdb) break main
  Breakpoint 1 at 0x118e: file my_application.cc, line 16.
  (gdb) run
  Starting program: /home/kenny/work/test/ccpp_jaingcheng/my_app
  
  Breakpoint 1, main () at my_application.cc:16
  16      {
  (gdb)

每次碰到一个断点，gdb都会把你的程序停下来，你就可以用print命令去打印你那些变量
（现在你应该已经知道变量是什么了）的值了。这些有用的命令包括这样一些：

1. next：向下走一步，遇到函数把整个函数当作一步
1. step：向下走一步，遇到函数跳到函数里面去
2. cont：继续向下运行
3. print： 打印变量的值
4. kill：停掉程序
5. list: 显示现在的程序的源代码

一般的调试，知道这几个就够了，反正你能停下程序，能看变量的值，可以继续程序，你
的程序的流程基本上就都知道了。

gdb的命令都自动匹配的，只要没有重复，只写一部分就够，比如前面的next，写n就够了，
print，写p就行了。gdb还运行你通过回车直接重复上一条命令，所以，你用next向下走一
步，然后你还想再走一部，就不需要敲命令了，直接回车就行了。

如果想知道每个命令可以带什么参数，可以用help命令看，比如：::

  (gdb) help break

这回显示break的用法，break的用法挺多的比如：::

  (gdb) break my_application.cc:16

这是在my_application.cc的第16行停下来。如果你总共就一个文件，或者当前调试就是某
个文件，你也可以省略前面的文件名（和冒号），这样写：

  (gdb) break 16

如果你设置了很多的断点，你可以用info命令来看设置在哪里了：::

  (gdb) info breakpoints
  Num     Type           Disp Enb Address            What
  1       breakpoint     keep y   0x000055555555518e in main() at my_application.cc:16
          breakpoint already hit 1 time
  2       breakpoint     keep y   0x0000555555555149 in test_sum() at my_application.cc:5

然后你可以用delete命令删掉其中一些，比如你可以这样删掉第一个断点：::

  (gdb) delete breakpoint 1

查看变量用print明明，比如你有一个变量叫a，现在想知道a等于几了。你可以：::

  (gdb) p a

print命令可以带格式要求，比如你可以用下面的方法按二进制，八进制，十进制，十六进
制，甚至当作浮点，输出a：::

  (gdb) p/t a
  (gdb) p/o a
  (gdb) p/d a
  (gdb) p/x a
  (gdb) p/f a

gdb一定程度上甚至可以直接通过这种方法调用一个函数，比如你有这个变量a，你还有一
个做加法的函数add，你可以这样：::

  (gdb) p add(a, 3)

gdb会先调用add(a, 3)，然后把它的结果打印出来。

和p类似的还有一个命令x，它和p的主要区别是它是从内存的角度解释后面的变量（当作一
个地址），比如你想输出前面的变量a的内容，你可以这样：::

  (gdb) x/x &a

&a取a的地址，x要求输出x的内容，x是禁止。如果你要真的看内存里面的内容是怎么放的，
你可以用这个命令。

和p命令不同，x命令是不看a的类型的，所有东西给它，它都当作指针，无条件解释里面的内容，
所以你可以按不同的长度来运行它，比如下面的命令分别按字节，双字节，四字节，八字
节，字符，字符串的方式解释它：::

  (gdb) x/b &a
  (gdb) x/h &a
  (gdb) x/w &a
  (gdb) x/g &a
  (gdb) x/c &a
  (gdb) x/s &a

此外，由于这是内存，你可以决定输出多少个成员，所以，一个完整的x命令可以是这样的：::

  (gdb) x/10tb &a
  (gdb) x/20xw &a
  (gdb) x/5og &a

这分别表示：

1. 按字节为单位，输出10个二进制内容
2. 按4字节为单位，输出20个16进制内容
1. 按8字节为单位，输出5个八进制内容

还有一个用来看数据的命令叫display，可以让你每次停下来自动打印变量的内容，这样可
以省不少事，这些你试一下就会了。

display的删除和breakpoint一样，可以用delete display <id>来删除。

C/C++的标识符（变量或者函数都是标识符）都有作用域，add函数的i和sub函数的i，就不
是同一个。所以，使用这些变量的时候要注意当前的作用域在什么位置上，如果你调用了多层
的函数，每层函数的i都是不一样的。想象一下，你的main调用了add，add调用了sub。每
个函数都有一个i，然后你在sub里面遇到一个断点，用p i看i的值，你会看到谁的i？

当然是sub的。

但是，如果你现在想看add的i怎么办呢？这需要bt和frame命令。你首先运行bt，输出结果
是这样的：::

  #0  sub (a=3, b=-4) at test2.c:4
  #1  0x0000555555555184 in add (a=3, b=4) at test2.c:8
  #2  0x00005555555551a8 in main () at test2.c:14

这个#0, #1, #2叫做当前断点的“帧栈”，frame stack。每个函数叫做一个frame（帧），
越早调用的函数就压在最下面（所以叫一个栈，Stack）。如果你想看其他函数的变量，就
需要切换到那边去，比如我想看main的i等于多少。我可以这样：::

  (gdb) frame 2
  (gdb) p i

这是先把帧切换到2这个位置，然后看这个上下文的i了。

那如果我们在main里面先调用了add，再调用sub（而不是在add里面调用sub），但我们在
sub里面断住了，我们还能访问add里面的i吗？

当然不能了，因为函数退出，函数自己的变量就不存在了。frame stack之所以可以存在，
只是因为stack里面的每个函数都还没有退出而已。

还有一个命令可能会有用：::

  (gdb) tui enable
  (gdb) tui diable

这可以让你一直看到程序运行到哪里了，试一下就知道了。

其他的命令，等你编的程序变得很复杂再学吧。

一些其他技巧
============

初始化脚本
----------

很多时候，我们调试到后面了，错误出现在程序的后面，我们懒得每次都运行gdb，然后设
置这个断点，那个断点的。正如我们一开始说的，程序员会让一切重复的行为自动化。

所以gdb也是支持初始化脚本的，就好像bash有.bashrc，vim有.vimrc一样，gdb也有一个
.gdbinit的脚本，你调试哪个程序，就在那个程序的目录下放这个脚本，把你希望启动
gdb后每次都要运行的命令放进去，下次就不用再弄一次了。

比如我们要调试程序my_app.exe，我们希望每次进入gdb以后，自动给add和sub函数设置一个断点，
我们只要这样写一个.gdbinit就可以了：::

  file ./myapp.exe                     # 这是相当与gdb ./myapp.exe
  break add
  break sub
  run

之后你直接在这个目录中运行gdb，程序就会直接运行到add或者sub上就停下来。

不要太依赖gdb
-------------

很多人第一次接触gdb等调试工具后，会觉得非常Cool，离开gdb就不会调试程序了。好像
觉得自己可以看到程序的所有变量，可以控制程序执行的每一步，仿佛掌控了整个程序。

所以他们每次程序出了错，都想单步一次，觉得这样就会发现错误了。

但这样常常是浪费时间的。

你能看到所有的变量不错，但你有空看完一个a[100][100]的数组吗？——不要尝试和计算机
比精力，你没有计算机的精力。还记得吗？我们比计算机强的是抽象逻辑能力。

所以，我们要从逻辑分析上思考整个程序的工作原理，看看它如果正常运行的时候，到底
应该“呈现”成什么样。然后根据需要甚至断点，并有目的地去看特定的变量，这样才会真
正发现bug在什么地方。否则就会出现不少初学者常见的那样，一遍遍跟踪程序，觉得自己
在“调试”程序，但无论跟踪多少次，都发现不了问题在哪里。

理解这一点，你也会发现，很多时候你不需要用gdb，用好cout就可以了。想明白你的逻辑，
然后在关键的地方把相关的信息打印出来（这种情况下，一般会用cerr代替cout，表示输出
到错误输出控制台上），这样也可以完成调试。

总之，调试的本质是暴露更多信息让我们判断程序的逻辑有没有错，关键在于想清楚你要
什么信息，不要把调试变成反反复复的单步执行的过程。
