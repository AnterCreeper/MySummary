.. Kenneth Lee 版权所有 2022

:Authors: Kenneth Lee
:Version: 0.1
:Date: 2022-12-19
:Status: Draft

6.1
***

本文基于kernelnewbies.org的跟踪的基础信息，加上查阅相关感兴趣的文档和代码写成。
[1]_

发布时间：2022年12月11日。

大特性
======

Rust支持
---------

内核开始支持Rust了！

相关代码在rust中。根据文档，现在只有x86支持。编译器用的是LLVM的，以后要扩展支持，
至少也需要支持LLVM。

我简单编译了一下，在我的机器可以运行rustc和cargo的情况下，make menuconfig 无法
使能RUST支持。按文档的说明执行make LLVM=1 rustavailable失败，感觉还有不少工作要
做。现在就先不深入看了。

但看补丁，当下的工作主要是把一些最基本的Kernel服务，比如alloc等，封装成rust的
crate（相当于库，不过rust的应用程序也叫库）。现在封装的接口很有限，用来写驱动肯
定是不行的。只能说工作刚刚开始，可以慢慢观察发展。

多代LRU
--------

一个新的LRU算法，配置项是CONFIG_LRU_GEN和CONFIG_LRU_GEN_ENABLE。算法的参数在
/sys/kernel/mm/lru_gen/中。调试信息在/sys/kernel/debug/lru_gen_full中。作者是
Google的Zhao Yu。补丁上有说一些用户提到在高内存压力下这个性能比原来好很多。

在我的双核虚拟机中这两个文件的呈现是这样的： ::

  root@debian:/sys/kernel/debug# cat lru_gen
  memcg     0
   node     0
            0     130465          0       10326
            1     130465        228           0
            2     130465          0           0
            3     130465       9997       22724

  root@debian:/sys/kernel/debug# cat lru_gen_full
  memcg     0
   node     0
            0     204104          0       10332
                       0          0r          0e          0p          0r          0e          0p
                       1          0r          0e          0p          0r          0e          0p
                       2          0r          0e          0p          0r          0e          0p
                       3          0r          0e          0p          0r          0e          0p
                                  0l          0o          0y          0n          0f          0a
            1     204104        228           0
                       0          0r          0e          0p          0r          0e          0p
                       1          0r          0e          0p          0r          0e          0p
                       2          0r          0e          0p          0r          0e          0p
                       3          0r          0e          0p          0r          0e          0p
                                  0l          0o          0y          0n          0f          0a
            2     204104          0           0
                       0          0r          0e          0p          0r          0e          0p
                       1          0r          0e          0p          0r          0e          0p
                       2          0r          0e          0p          0r          0e          0p
                       3          0r          0e          0p          0r          0e          0p
                                  0l          0o          0y          0n          0f          0a
            3     204104      10001       22724
                       0          0R          0T          0           0R          0T          0
                       1          0R          0T          0           0R          0T          0
                       2          0R          0T          0           0R          0T          0
                       3          0R          0T          0           0R          0T          0
                                  0           0           0           0           0           0

算法的特征就是名字是说的Multi-Generational LRU。原来的LRU只有两层（tier），
active和inactive，少用的页就慢慢退火成为Inactive的，然后清掉，多用的就继续保持
在active里面。Multi-Gen LRU算法提供更多的层，具体怎么样的我没有看了。

KMSAN
-----

Kernel Memory SANitizer。用来查变量未初始化用的，成本比较高，只适合在测试环境里
面用。配置项是CONFIG_KMSAN，使能有运行发现有变量未初始化会在内核打印中直接用BUG
打印打印出来。在函数前面加上__no_kmsan_checks可以关闭对这个函数的检查。也可以用
__no_kmsam_memory直接要求编译器不产生检查代码（避免影响汇编逻辑）。Makefile中还
可以通过KMSAN_SANITIZE_xxxx:=n关掉对xxxx文件的检查。也可以用KMSAN_SANITIZE:=n关
掉整个目录的检查。

算法的原理是给每个变量都分配一个影子变量，如果变量没有初始化，把影子设置成未初
始化称为一次Poison。初始化就称为一次unpoison。编译器和内核配合，在分配变量，分
配内存的时候把变量poison了。编译器在使用变量的时候插入代码检查变量是不是poison
的，如果是，就报错。

这个功能在用户态已经支持了，只是把一样的功能移到内核而已。

BPF专用内存分配器
-----------------

BPF实现了自己专用的内存分配器，用于处理复杂的运行环境问题（比如正在处理中断上下
文，特别是被NMI中断影响的时候，还有内存缺页需要分配的时候等等）。算法类似
mempoll，函数名字也类似，叫bpf_mem_cache_alloc/free()。基本原理大概就是为不同上
下文，不同CPU创建不同的对象独立分配。所以这个东西不好做内存统计的，我还没有深入
看现在的版本这个问题是否解决了。

其实我不怎么关心BPF的发展，我总觉得这个东西很破坏架构。因为它在内核中创建了很多
额外的逻辑，而这些逻辑没法作为一个逻辑闭包单独得到一个扇出比较小的结论。所以这
个东西没法总结，这样给内核的逻辑引入了很多的可能性，特别容易错，我个人是不喜欢
这样的设计的。我宁愿保证一个静态的逻辑是正确的，而不想老去想“这里加进来一个变数，
那里加进来一个变数，整个逻辑又变成什么样了。”

但我还是把这个特性作为一个大特性放到一段中，而不是作为一个列表条目放到下一章。
因为最近和人讨论把缺页的动作做到硬件上的可能性。

做硬件的同学看到OS补页的原理，总是觉得“我也行”，而且他们觉得这个事情很烦：我发
现你缺页了，我还有告诉你，你其实也没有干什么，就是找了一页，又填到我的数据结构
中（页表），这不是多余的通讯吗？你把这些页给我，我来给你填，这不是好好的吗？这
为什么不行？

这个问题从软件的角度不好回答，因为要素太多了。我简单想想，大概会有这么一些：

1. 你怎么知道我是不是想补页？你至少得知道我的VMA信息才能肯定这一点，而且，你还
   不能只知道我的范围，你还要知道我的属性，因为我可能不但是要补页，我还可能需要
   COW，只读，或者其他的。这意味着，我软件要改什么补页策略，也要改你的硬件逻辑。

2. 提前把一些页给硬件，让硬件按需补充。NUMA等考量要不要也告诉硬件？硬件怎么知道
   我的意图？这些信息要不要告诉你硬件？你硬件有能力处理这么多逻辑，你还是硬件么？

3. Midgard就多几个VMA硬件都觉得非定长多个段不好处理，现在那么多负责逻辑都让硬件
   处理，硬件就能搞定？

4. 有虚拟化以后，我硬件要不要告诉你两层翻译的逻辑？但两层软件属于两个特权级，统
   一到一个硬件对象上，这不合理吧？那两级需要两个硬件对象，供给两个特权级？但分
   配是两个软件的分配，物理页是同一个物理页啊，这个协议很不好写吧？

5. 如果这个代码是fixup的代码硬件怎么知道？

6. 每个软件对象，每个CPU，都需要独立的预分配的自由页，这些自由页还需要在有大页
   机会的时候可以自由合并，但一旦分离给了硬件，硬件没法针对全系统做这种调度吧？
   联系到社区对这个BPF分配器的质疑，这个页的Accounting怎么做？Accounting要算到
   每个进程里的，你硬件难道要每个进程给我单独统计数字？

7. 页都有backlog file，只要backlog file uptodate，对应的page我软件说释放就释放
   了，这件事情你硬件怎么处理？而且，如果你的硬件可以修改页表，我软件也可以修改
   页表，双方在内存上就得有个互斥算法，这个怎么保证效率。再说了，如果这个缺的页
   是swap出去的，你补页的时候还要给我吧backlog file加载回来，你硬件怎么做这个事
   情？

8. LRU算法怎么做？6.1开始提供新的Multi-gen LRU了，那个页更热，谁应该退下去，硬
   件可以取代软件来做吗？

9. 硬件能知道我这个页是代码吗？知道需要刷新对应的icache吗？

1-5这些我都可以退化为“正好要无脑补页的地方才使能这个功能”，但6-8是没法这么搞的，
9我猜通过复杂的逻辑组合可以知道，但如果软件写得技巧性一点，硬件也是判断不出来的。
而且“正好要无脑补页的地方才使能这个功能”，这是否实际能作出效果，这要试过才知道。

总的来说，页表分配这件事是个复杂的软件逻辑，而不是无脑的软件行为。你当然可以把
所有事情都接管过去，因为本来软硬件都是逻辑处理。但我们一般都是把复杂逻辑给软件
（以便修改），把粗暴逻辑给硬件，如果真要做硬件加速，我们首先应该把软件的逻辑写
出来，看到暴露出来的软件逻辑可以简单粗暴用硬件搞定了，再硬化。这比较靠谱一点，
看到软件某个流程比较曲折，就像整个用硬件行为取代，我觉得是没有前途的。

其他有趣的东西
==============

1. KCFI支持。之前的CFI（Control-Flow Integrity，）支持是ARM加的，只有ARM平台支
   持了，现在加入了x86支持，叫KCFI。我以为这个特性是Intel做的，但实际上是Google
   的人做的。

2. Intel的Huangying在NUMA平衡算法上一些调整，优化在多种不同速度内存的时候，
   慢速内存的热点的迁移策略，把pmbench的不同测试项有不同程度的提升，部分可以达
   到25%以上。

3. todo...

参考
====

.. [1] https://kernelnewbies.org/LinuxChanges
