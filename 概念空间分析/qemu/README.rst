.. Kenneth Lee 版权所有 2020-2025

:Authors: Kenneth Lee
:Version: 1.0

qemu概念空间分析
****************

介绍
====

本章分析qemu的概念空间，这个分析最初来自这个总结：

:doc:`../../软件构架设计/在qemu中模拟设备`

但随着涉及的调研主题越来越多，很多原来可以忽略的概念都不得不去面对了，所以就扩
展成这么一个完整的分析。

前面的提到的文档写于2019年，现在读者看到的这个介绍写于2025年6月，这个时间我正
在用qemu模拟一组新的指令，以及和这组指令有关的一些设备。所以我实际上断断续续维
护这个概念空间分析已经有6年了。而我写这种概念空间分析也有十几年的实践经验了。
最后，使用AI进行辅助编程我也有一年左右的实践经验。综合这些这些体会，我想着趁着
这次重整这个概念空间，整理一下我对这种概念空间建模的方法的使用经验，做一个总结。

我是做架构设计工作的，但代码也没有少写，这样导致我的设计工作不能不面对概念空间
建模的问题。因为我开发的工作面太广了，我又要看芯片的设计逻辑，又要看模拟器的设
计逻辑，看BIOS，OS，编译器，开发库，应用程序，云管理工程，Python，机器学习，这
些东西我都得看（或者修改）。因为你比如决定设计一个指令来支持机器学习的性能提升，
你不面对它们的细节，你就没法预判你的特性落地需要克服哪些障碍，那么这个特性成功
的机会也会变得很低。

但人不大可能记住那么多细节，那怎么办呢？只能是具体在需要改哪里的的代码的时候，
就去增强那个部分的认识。而正如我在这里介绍的那样：
`道德经直译V3介绍 <https://daodejing-translation.readthedocs.io/zh/latest/V3%E7%9A%84%E8%AF%B4%E6%98%8E.html>`_
，我们记住的东西，主要在我们的神经网络的“隐层”中，而不是在Token上。而隐层无法
用语言去描述（因为语言就是Token了）。所以最终我很自然的选择就是，我每次修改某
个东西的时候，我都会把它涉及的概念和关键的特征，进行一些整理，等下次我再要修改
这部分代码的时候，我就先看一次对这些概念的总结，“激发”一下自己这部分的“隐层数据”，
让自己进入修改这部分代码的状态，这些写概念总结的方法，我就称为“概念空间建模”。

概念总结这个东西，有三个关键的麻烦点：

第一，它不精确，不精确才是它的目的。要精确，你要记住所有的代码，那才是精确。甚
至那个也不够精确，代码用不同编译器编译，得到的结果也不一样（比如用32位和64位系
统编译的行为就是不同的）。所以，就没有“严格精确”这回事。这和机器学习一样，你看
到细节就看不到整体，看到整体就看不到细节，这两者本来就不可共存。我们做概念空间
建模，就是为了激发我们的隐层，而不是重建所有的隐层，所以你写多了，它的效果就没
有了。

第二，它会发展。这个qemu的概念空间分析，中间经过了6年，很多概念，我一开始看的
代码的样子，和现在的代码的样子，其实已经和不一样了，概念本身也转义了。我刚入行
的时候，整个行业气氛都认为“代码与文档应该保持严格一致”，这种想法这些年稍微务实
的人都知道是个笑话。在特定的高安全要求的领域可能还能维持，在主流的开发中，同时
维护两套逻辑，这不符合软件现在这个发展规模的基础现实。所以，这样的概念分析就不
可能和现实完全一致。甚至，我们有些同行不一定意识到，如果概念空间建模要和现实完
全一致，这个模型的信息量就会比代码本身还大。

这有点反直觉，但事实就是：代码只需要保证在最后一个版本（HEAD）上逻辑自洽，而概
念空间建模需要保证代码的逻辑自洽，因为它通常用于维护不同的软件版本，所以它是所
有版本的立体空间的二维化。

面对这样的信息量，如果我们把时间消耗在维持模型的正确上，我们就变成舍本逐末了。
所以，实际操作中，我就是需要改到哪里，就更新哪里的概念建模，其他地方就不管它了。
这种建模就是具体要更新哪个部分推动一次建模的，不会进行严格的全体更新。

第三，可能根本没有人会承认这个模型。这一点让我举个例子：我在单位和人讨论某个设
计怎么修改的问题，我有时会问修改的人：你这个“Agent”的语义具体是什么？然后他会
说：“我不能定义它，因为这是XX部门的YY说的”。然后我就问：“你不能定义它，你怎么
就能改这个代码呢？你的代码不是要和这个Agent打交道吗？”

这就是这个问题有意思的地方：你建立模型，代表的是你对这个问题的态度，不是创造者
对这个问题的态度，他未来维护也不见得就能维持这个态度。你不能认为他不维持这个语
义，你现在就不能定义这个概念的语义。因为你如何理解一个概念的语义，会决定你如何
做出你的决策（比如编码）。

所以，这个问题对很多希望逻辑简单的人来说，很难接受，他们希望做的事情和代码一样
精确：特定的行为，总是得到特定的答案。但现实是——至少以我的经验——我也想也是很多
其他软件工程师的经验——一个概念空间建模确实帮助我们建立的思维的基础，让我们的很
多思考可以依附上去，可以让我们面对复杂的信息结构可以仍进行有效的思考。

这样的概念空间模型，既不精确，也不完全正确，而我们依赖它构造出精确而正确的代码
或者产品。我们不追求它整体的精确和正确，但我们依然会评价它某个地方不够精确和正
确，这取决于这个地方抽象的特征，是否影响我们的关键决策。

这对很多人很难接受，但口头上不接受的人行为上实际上就是接受它的。你不肯进行纸面
的概念空间建模，只是在脑子里建立一个模模糊糊的模型，然后靠不思考，而用有些具象
去“试”结果而已，这只会让你的逻辑大厦更多破绽，产品实现得更加糟糕。

一个产品要完成一个计算，这个计算可以完成在CPU上，可以完成在虚拟机上，可以完成
在OS上，可以完成在用户态，可以完成在另一台代理主机上，那么放在哪个上面是最优的
呢？这和这些主体的概念定位有关，不建立这种模型，随便都放在一个地方，当下肯定是
没有问题的。但多放一些以后呢？它们就开始逻辑冲突了。稀烂的概念空间建模，影响的
是大量逻辑的集成，它决定你的逻辑大厦能搭多高，越缺乏这种控制，你就约搭不高。你
可以说“这无法用数学证明”，但我不关心，我认为大部分实际写一段时间代码的程序员都
能体会到这一点。

而这个能力，我也认为是AI短时间内不可能取代人的关键能力。我在实现我的qemu代码和
建立概念模型的时候，经常让AI帮我进行分析，或者写部分代码。比如我会这样问它：

* qemu代码中如何实现删除一个动态创建的qdev？
* qemu中用qemu_irq_pulse()产生一个中断，在OS收不到，但用qemu_irq_raise()却可以
  收到，为什么？
* ……

这些它都能给我挺好的代码和建议的。但如果我让它给我组合所有这些代码逻辑，它就开
始胡说八道了。我觉得，一旦逻辑线多了，它的神经网络结构就是没法控制哪个权重高，
哪个权重低，或者维持住每个逻辑线都可靠这个问题了。我觉得人的神经网络在解决这个
问题上表现得还是好得多的，另外，人可能在和Token的互动上能力也是比AI好的，我们
做这种概念空间建模，说到底就是分了主题把我们关心的要素分解到多个Token组成的上
下文上，然后综合所有这些总结形成一个更大的复合逻辑结构，而AI每次只能靠有限的那
些上下文（包括思维链）来控制思考方向，就不可能形成那么大的判断结构。

同时，AI也没有人通过现实训练出来的隐藏来控制对很多概念的认识，它对概念的认识都
是来自其他人的Token，所以它只有Token的规律来控制思维方向，没有很多Token的真是
感受信息，这也会导致它只能按“套话”来思考问题，而不是从现实出发来考虑问题，这些
都是人的“主管能动性”不可被取代的地方。

但如果你追求“别人给我确切的要求我才能写出正确的代码”，那么我想，你真的就很快被
AI淘汰了。

最后说明一下，当前这个文档的分析，主要基于qemu主线9.2.90。

基础名称空间
============

我们先定义一些基本的名称以便后面容易说清楚各种概念：

Host
        Host表示模拟虚拟机的那个平台。这个概念比较模糊，可以表示Qemu这个程序，
        也可以表示运行Qemu的那个操作系统，反正不是被虚拟的那个平台。

VM/Guest
        这表示被模拟的那个平台。如果我们在X86上模拟一个RISCV的机器，X86就是Host
        ，而RISCV是VM或者Guest。如果我们说Host的CPU，那么这个CPU是X86的，而如果
        我们说Guest的CPU，那么这个CPU是RISCV的。

Backend
        这是Host中模拟Guest中某种行为的那些代码。比如我们用Qemu模拟了一张e1000
        网卡，在Guest中我们要“看到”这张网卡，我们需要在Guest的OS中装e1000的
        驱动，这个驱动是Guest中的。但为了模拟e1000的行为，我们也需要在qemu装
        一个驱动，这个驱动我们称为这个e1000的backend，它是Qemu概念上的。

Qemu使用glib作为基础设施，所以，读者如果需要和代码细节进行对应，最好对GLib的数
据结构有基本的了解，Glib提供基本的内存，线程，链表，事件调度等基础设施的封装，
本文本身不会深入到这些概念上。

.. toctree::
   :maxdepth: 2
   :caption: 子主题

   执行模型
   qom
   MemoryRegion
   中断
   pci
   virtio
   CPU模拟
   其他小设施

.. vim: set tw=78
