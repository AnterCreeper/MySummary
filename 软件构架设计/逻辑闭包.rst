.. Kenneth Lee 版权所有 2020

:Authors: Kenneth Lee
:Version: 0.1

逻辑闭包和抽象概念定义
**********************

逻辑闭包
========
我尝试在本文中定义一个在架构设计讨论中经常要用到的概念，我把它称为闭包，Closure
，取它在数学意义上的意象。数学上的闭包的定义是这样的：

In mathematics, closure describes the case when the results of a mathematical
operation are always defined.

简单说，我在一个集合中定义了一组成员和针对这组成员的操作，这些操作的结果，仍在
这集合之内。

数学上这是非常严格的定义，但在构架设计上我们做不到这么严格，因为架构设计是个逐
步发现边界的过程，什么东西放在A模块中，什么东西放在B模块中，或者什么东西放在层
一，什么东西放在层2，这是逐步细化和维护中“决定”的（注意，不是发现的，而是决定的
），这个边界并非天然存在，是我们做了选择，后面在不断发现新的信息和引入的新需求
在强化这个边界。所以，这里引入逻辑闭包这个概念，是要给出一个逻辑空间，这个空间
引入的概念，进行逻辑推演后，结论的描述仍在这个逻辑空间的概念范围内，而不需要引
入额外的信息去补充。

比如一个链路层的逻辑空间，它包含节点，链路，报文，Payload这样一些概念。它可以构
成一个逻辑闭包，因为我们讨论链路有关的东西，只需要用到这些概念就够了，我们决定
是否重发一个报文，只需要知道报文的目标节点是否回了响应报文，而不需要额外的比如
Payload中的数据是管理数据还是业务数据。我们在逻辑闭包之内构造了一个自恰的概念空
间，在这个空间中，我们不需要额外的信息就可以进行各种推演，并得到一些演绎的结论。

我们引入逻辑闭包的概念，主要是为了避免进入额外的细节。比如前面这个例子中的链路
层逻辑闭包，我们其实不关心报文的格式，因为无论报文的格式是什么，我们的逻辑都可
以成立。但如果我们引入了细节，这个逻辑可以被应用的范围就少了。比如，我们认知
Payload的格式，或者我们认为我们知道每条链路都只有1到2跳。我们就不知道我们原来的
逻辑推演中包含了这个成分，那么这个逻辑闭包就不能用于Payload不是这种格式，或者链
路被延长到有3跳的情形。

清晰定义一个逻辑闭包的概念空间，可以让我们用\ :doc:`../道德经直译/恍惚`\ ）的形
式使用概念空间的概念。比如“链路层总是可以保证协议层发送的消息不会丢失”，为了保
证这一点，链路层内部有大量的逻辑去保证丢包重传，流控，链路断开重新选路等等，你
分析协议层逻辑的时候如果要考虑这些细节，你的逻辑就会非常复杂。常常会复杂到你的
大脑无法判断这个逻辑是否是严密的。

从逻辑闭包的角度看待一个逻辑设计，反过来还能让我们判断一个逻辑闭包的结论范围。
比如你的链路层逻辑闭包没有包含QoS分类信息，那你在这个闭包内就不可能进行包调度。
清晰定义逻辑闭包的范围，也让我们知道这个名称黑盒可以作用的范围。我经常看到有设
计师为构架而构架会尝试设计“通用软硬件接口”，或者“万能模块间消息接口”这样的东西
。从逻辑闭包的角度来看这个问题，一个逻辑空间没有约束就没有信息（本质上是约束）
，没有信息就不会产生衍生逻辑，没有衍生逻辑，这个逻辑空间就没有意义。所以，“通用
软硬件接口”这个需求本身毫无意义，你首先要给定你的约束，你才会有建立一个独立逻辑
闭包的驱动力。你的“因为”，“所以”都需要这些基本约束作为根。

说到底，“逻辑闭包”是概念空间的另一个说法，因为实现“逻辑闭包”是我们建立一个概念
空间的基本要求。否则我们随便建逻辑链就可以了，分成一个个独立“空间”干什么？我们
强调逻辑闭包，只是强调建立概念空间在收缩信息范围上的那个要求而已。

抽象概念定义
============

要能做好逻辑闭包的设计，我们必须先要学会严肃的抽象概念的定义。抽象定义的是一个
范围，比如1，是一个具象，我们对它的取值有确切的理解。而“自然数”是一个抽象，它
有众多的取值，1，2，3，4，......都是它的取值。当然，这是一个相对的概念。严格来
说1也是一个抽象的概念，因为自然界只存在“一个苹果”，“一片树林”这样的“具象”，一
这是对这些东西某个特定属性的一个“抽象”而已。在我们可以在某个上下文中上有一个共
识，确定什么是抽象，什么是具象。

当我们定义一个抽象，我们会有两个要求，第一，你必须给出明确的问题域，也就是你为
什么要讨论这个问题。因为抽象本质上是一种“分类”，我们提出自然数这个概念，就是要
区分具有特定性质的东西，区分不具有这种特质的东西（比如小数）。你没有目的地说一
个概念，这个概念没有正确与否可言。

给出明确的问题域，你的逻辑就必须穷举它的所有可能性。你定义一个逻辑，只包含它一
个子集，其他部分当看不见，我们讨论啥？这种“部分成立”的逻辑，就构不成抽象。

第二给问题是你必须对它包含的具象有明确的理解。这其实仍是前面这个穷举可能性的要
求。你要穷举可能性，必然是用一个个的逻辑闭包分隔你的所有可能性，否则只能是一个
“差不多”的东西，它的结果没法用。

今天我评审一份设计，里面有这样一个描述：

        | Master执行Slave.call命令Slave从Idle状态变为Running状态，
        | Slave执行到halt指令，跳回Idle状态，Master从Slave.call命令
        | 继续执行……

这个逻辑空间混合了Master和Slave的执行行为和Slave的状态变迁。我第一个反应是考虑
Slave的状态机到底是个独立的闭包，还是属于当前逻辑定义上下文的闭包。是Master执
行需要Slave的状态作为基础呢？还是Slave有一个完整的状态机管理，并用这个状态机的
状态结果来控制Master的行为呢？这里的描述既没有构成Master对Slave状态机的一个“要
求”，也没有提前推演Slave的状态机（让它形成一个闭包，这也可以通过索引其他定义决
定），这段描述的信息熵就非常低，

这个例子和我们写程序很像，你写一个程序，循环打印hello world。你的程序这样写：

.. code:: python

   def print(str):
     f = open(stdout)
     for c in str:
       f = write(c)
     f.close()

   def loop_print_hello_world(n):
     for i in range(0, n):
       print("hello world")

这里print和loop_print_hello_world就各自构成了一个独立的逻辑闭包，因为它的行为
在它们内部是完全自恰的。loop_print_hello_world()的逻辑链中使用了一个完全封闭的
print的概念，就算print修改成用putc()来实现，不用for循环，而使用递归，这样的逻
辑变化，都不改变loop_print_hello_world的逻辑。但如果你的程序是这样写的：

.. code:: python

   i=0
   f=0
   def print(str):
     i++
     for c in str:
       f = write(c)
     f.close()

   def loop_print_hello_world(n):
     while i<n:
       f.open(stdout)
       print(__function_name__)

这就不是两个函数——你有本事不看另一个函数，独立维护其中一个函数试试？

很少人在写代码的时候犯这样的错误，主要是高级语言在语法上就enforce了很多所谓高
内聚，低耦合的要求了。但架构设计是自然语言描述，人们就开始忘掉这个要求了（主要
是它很烧脑），这样这些逻辑就全搅在一起了，但这样缺乏组织的逻辑根本就没有用。如
果是代码，我们勉强可以靠测试来验证它。高层逻辑不能构成一个个独立相对简单的闭包
，你就没法校验这些逻辑是成立的还是不成立的。

实际上我上面提到的这个文档更大的问题是它在一开始就没有定义：为什么Master需要调
用Slave？这解决的是个什么问题？大部分时候，我们都隐隐约约知道我们为什么要做这
件事，但你要做一个严密的逻辑闭包，你还是需要严格（注意不是详细，而是严格，这里
强调的是无二义，可穷举）去整个这个问题域，你才能保证你的推演是合理的。

但说到底这两个问题都是一脉相承的，我们没有对逻辑闭包的认知，就不会在乎问题的边
界，这样进行逻辑推演，其实跟不推演没有区别，不如直接编码呢。


.. vim: set tw=78:
