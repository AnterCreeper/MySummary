.. Kenneth Lee 版权所有 2021

:Authors: Kenneth Lee
:Version: 1.0

一个架构设计实例：qemu iommu
*****************************

介绍
====

最近要改进qemu一个iommu驱动的代码，做了一个简单的高层设计，情况比较典型，我把这
个设计作为一个架构设计的实例说明一些架构设计的概念。

关于qemu的基本认识，读者可以看这里：

:doc:`../概念空间分析/qemu`

IOMMU是一种升级的DMA设备，它的作用是对设备发出的地址进行CPU MMU一样的处理，把虚
拟地址转化为物理地址，再进行最后的访问。

qemu在实现这个特性的时候，还停留在这样的认识上，所以，它对这个功能的抽象，是提供
一个这样的回调函数：

.. code-block:: C

   static IOMMUTLBEntry smmuv3_translate(IOMMUMemoryRegion *mr, hwaddr addr,
                                         IOMMUAccessFlags flag, int iommu_idx)
   {
       ..
       IOMMUTLBEntry entry = {
           .target_as = &address_space_memory,
           .iova = addr,
           .translated_addr = addr,
           .addr_mask = ~(hwaddr)0,
           .perm = IOMMU_NONE,
       };
       ...
       return entry;
   }

这个函数对于处理类似CPU MMU那样的翻译，完成一般的DMA功能是完全足够的。但对于现
代IOMMU的功能，是完全不足的。因为现在IOMMU都支持多页表。比如ARM的SMMU，它支持地
址请求上除了有地址，还有sid和ssid，前者代表从哪个设备发出的（对应device id），
后者代表设备服务的是哪个进程（对应ASID）。

所以，如果你要支持现代IOMMU，qemu的框架就要修改。

.. note::

   我们先来讨论一下qemu的架构。你说qemu iommu框架的设计师，算不算没有架构眼光呢？
   因为他明显完全没有预见到IOMMU会发展成今天这样。但你也得这样想：如果他当初就设
   计了device id和ASID的概念，你肯定说他过度设计。关键的是，如果不深入了解新的情
   况，一个IOMMU该不该加入device id和ASID的概念，这是说不清楚的。他根本没有条件设
   计device id和ASID的接口细节。

   所以，我想请读者注意的问题是：架构是设计未来，但架构不是预知未来。qemu IOMMU
   在架构上真正的努力是保证IOMMU MR对其他设计的依赖减少，大部分设备看到的仅仅是
   Address Space，根本不知道IOMMU的细节，让你有机会在一个范围内修改，而不至于一
   旦修改，整个系统都要重写。我们看架构好不好，主要是看后面留下的余地多不多而已，
   不是预先知道一切。而这个余地多不多，首先你不能作死，在这个前提上，很大程度还
   要看你的敏感，还有你的运气。

   这就是为什么没法给老问“这难道不能跑吗？”的人讲架构，为什么要说架构是“信念”。
   （\ :doc:`架构首先是一种信念`\ ），为什么架构这个领域神棍那么多。


问题建模
========

qemu的当前对上面的问题有个临时的解决方案。方法是先把device id和asid设置到IOMMU
设备上，然后再发起地址请求，这样做translate的时候就可以直接从设备上获得这些参数。

这个方案的问题是明显的，就是如果两个设备共用一个IOMMU设备，两个设备同时发起请求，
就会存在一个设备的设置冲掉另一个设备请求的可能性。解决这个问题的方法有两个可能：

1. 增加translate的参数，提供device id和asid。

2. 绑定设置参数和发起地址请求两个动作，让其他人不能插入。

但深入想一下这个过程，第二个方案本质不就是第一个方案吗？为了做这个动作，你需要
增加一个调用，用于设置参数，然后再调用dma_memory_rw()。这样非要一起调的两个函数，
和一次调一个增加了参数的函数，这不是一回事？

.. note::

   很多工程师都不愿意写设计文档，他们觉得很多问题在脑子里就是清晰的，或者他们觉
   得设计文档不比代码多了什么。

   而我这里就给出一个例子：这就是一个逻辑视图建模。它不需要类图，不需要概念定义
   。它就是把关于翻译这个问题的视图单独抽象出来。我们不管你是平台设备还是PCI设
   备，我也不管你是ARM SMMU还是Intel DMAR。我只关心，作为一个基本功能是进行地址
   翻译的设备，它的翻译过程，应该如何抽象。

   当我把这些条件都Layout（取孔乙己“排出九文大钱”那个排的意象）出来，我才会看见
   第二个方案和第一个方案是一样的，我就不会做这种脱裤子放屁的事情。这是问题建模，
   提前设计的原因。

实际qemu现在的方案是什么样的呢？他们的方法是为每个device创建一个独立的IOMMU，这样
设置device id就一定不会冲突（因为只有一个device访问这个IOMMU），而ASID呢？它不
支持。

这个修改更简单，但收窄了支持范围了：

1. 它不支持ASID

2. 它不支持多个设备共享同一个IOMMU单元

这样对不对呢？大部分收窄范围，都能拿到“简化设计”的收益，只要这个范围足够支持产
品（是的，开源软件也有产品的概念，否则你就看不见它了）的市场拓展，所以，它对不
对完全看市场发展情况。

但对我来说，这显然不够，因为我就是要把这两者都支持了，我只能选升级translate的方
案。我要选择一个尽量不改变原来逻辑结构的方法把我额外加入的逻辑塞进去。

要给translate加参数，我首先要给dma_memory_rw()加参数，参数怎么抽象呢？一种方法
是device id和asid，但如果以后有其他的参数怎么办？这也有两种选择，一种认为这不会
变了，我们就是device id和asid，我们认知这两者了。还有一种呢？每种IOMMU都可能不
一样，那我们就用一个cookie表示。

我们把这两个方案Layout出来，想想那个好？

认知了device id和asid，我们在实现通用逻辑的时候，就可以帮忙处理相关的逻辑。不认
知，这些逻辑就只能由每个具体SMMU使用。我们把这个逻辑Layout出来，也是告诉IOMMU公
共框架：在我们第一次实现的时候，可能只支持SMMU，或者只支持AMD IOMMU。你知道cookie
里面是device id和ASID，但你不能碰。那个概念已经被抽象了。

这就是逻辑空间建模的作用，没有这个地图摆在面前，你到细节，就会失去方向。

就现在这个具体的问题，我是想不到我能拿这个device id和asid用来干什么，所以cookie
方案比较好。

然后我们的问题是：老的驱动怎么办？都修改dma_memory_rw()的调用吗？这个从代码上看，
都可以。但我们不从这个角度想问题，我们既然模拟真实硬件，我们从情理上看：对于真的
硬件，他们是怎么做的？

这个问题很简单：真实的硬件不可能换掉已有的IP，它们会继续发没有cookie的地址请求
。而新的硬件会发有cookie的地址。我们的模拟器不就是在模拟真实世界吗？我们未来的需求
肯定也会随着这个逻辑走的啊。

所以，我们的设计也很清楚了：dma_memory_rw()的接口不变，我们增加一个
dma_memory_rw_ex()，这个问题就和硬件解决方法是一样的了。translate的修改一样，真
实的IOMMU硬件在发不带cookie的请求是，这个硬件怎么做的，我们也可以一样模拟，这个
问题就解决了。

总结
=====
在本文中，我们做了一个简单的构架设计（或者叫高层设计）的概念空间建模演示。我希
望读者可以看到，架构设计到底是什么，为什么它是细节设计（或者说编码）不可取代的
设计，在进入细节设计前，没有一个这样的Layout和权衡的过程，你的选择都是无序的，
就很难走得长久。只是越是高层的Layout就会越困难，因为它的概念概括的范围就越广，
我们对它的属性就愈加的看不清楚。
