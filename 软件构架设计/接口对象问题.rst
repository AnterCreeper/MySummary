.. Kenneth Lee 版权所有 2023

:Authors: Kenneth Lee
:Version: 0.1
:Date: 2023-01-13
:Status: Draft

接口对象问题
************

记录最近一个架构概念建模的问题。有人定义了一个系统寄存器，用于设置CPU的行为，另
一方面，硬件也有其他流程，可以修改这个行为。

为了更容易思考，我用一个虚拟的功能来具像化一下这个问题。比如说这个功能是CPU定时
产生一个中断，你可以设置中断的触发时间，但同时呢，我们CPU里面还有一套逻辑，比如
如果收到另一个CPU的特定核间中断（IPI），会重设这个触发时间（比如会在原来的基础
上加上10分钟），这样软件访问这个系统寄存器（C），和CPU收到IPI对触发时间的影响，
这个协议应该如何描述？

有人建模这个模型的时候，把C具像化为和另一个CPU的接口，它这样表述这个概念空间：

.. figure:: 接口对象问题图1.svg

我认为这个建模是不好的。很多人感知不到这个不好，是因为他们在建模的时候没有注意
到存在那个我模糊展示的“定时器触发逻辑”的接口。它们以为这这是软件和IPI CPU两者对
一个存储体的互斥访问，而没有注意到，这个配置还有一个第三方也要决定访问时机的。

系统寄存器从来就不是一个存储体，而是一个CPU功能的“接口”，你甚至认为它是个指令都
是可以的，比如你用：::

  sysreg_write MINI_ENGINE <inst>

写一个指令到某个小引擎中，让它执行一条指令，甚至你可以要求这个指令没有执行完，
这个sysreg_write不能结束，这都是可以的。所以，把它的功能泛化为一个存储读写，你
就会需要表述非常多的其他逻辑。比如说，你得有个协议，说明谁可以更改它，这个更改
的过程先做什么动作，再做什么动作，不同长度的访问又是什么样的，等等等等。而这些
都和我们的定时器没有什么关系。这样建模就“不好”。

我们这个例子举得比较简单，你当然可以说我说好访问的三方访问这个寄存器都是“原子
的”，这个问题还是自恰的，但你们去看看内存的原子语义要定义多少东西（字长，对齐，
getter/setter……），这些定义有什么意义呢？我们又不需要这个东西，我们只是要做一个
具体的“功能”而已啊，我们没打算让系统寄存器变成一个CPU内的存储啊，变成CPU内的存
储对CPU并没有好处啊（比如前面那个执行内置引擎指令的行为中，我们就根本没有一个存
储）。

所以，如果我们针对功能去想这个问题，那这个建模就会是这样的：

.. figure:: 接口对象问题图2.svg

系统寄存器和IPI，都是对“定时器”功能的访问，我们说清楚写系统寄存器这个功能和IPI
发过来以后，这两个先后顺序如何处理的，这个很简单，其他东西都和我们定义的功能无
关，这个问题就解决了。为什么这个地方需要泛化为一个存储接口呢？

我想用这个例子说明：概念建模的关键在于你怎么“看待”一件事，到底一个系统寄存器读
写，是一个存储的读写，还是一个“功能的访问”，这个定性不同，就改变我们的设计细节
了。这些细节最终又反过来绑架我们某个高层抽象的语义。如果是存储的读写，那么，未
来我们所有系统寄存器的读写，我们都必须认为这背后都是有真实的存储实体存在的，但
其实这个约束对我们没有价值。一个系统寄存器，写一个1进去，都没有任何理由要求读出
来必须是1。我们都没有打算这样用这个功能，那你泛化一个多余的功能出来，就限制了我
们的自由度了。
