.. Kenneth Lee 版权所有 2022

:Authors: Kenneth Lee
:Version: 1.0
:Date: 2022-03-04
:Status: Draft

逻辑闭包V2
**********

介绍
====

本文是我关于逻辑闭包定义的一个新的版本。

原来的版本写在这里：\ :doc:`逻辑闭包`\ ，因为不断补充逻辑，那个版本的组织已经变
得很松散了，这个版本我根据这两年对这个概念的使用经验，用一个我觉得更好的角度来
描述这个概念的内涵和外延。

定义
====

“逻辑闭包”这个定义是我所有架构设计概念的基础。正如V1里面提到了，它最初来自数学
中Closure的定义：

        | In mathematics, closure describes the case when the results
        | of a mathematical operation are always defined.

它描述的其实是一个计算系统。比如，自然数配合加法，就构成一个闭包：自然数构成一
个集合，在这个集合中任选两个元素，经过加法计算以后，结果还是在自然数这个集合中。

同理，分数这个集合，加上加减乘除这些运算，也构成一个闭包。

我们把这个概念引入到逻辑推理中：如果我们引入了一组定义，如果用这一组定义进行逻
辑推理，这个推理的结果仍在这组定义中，那么，我们就认为我们这个推理，构成一个逻
辑闭包。

定义的内涵本身很简单，但其实问题比数学上的问题复杂得多。因为数学系统基本上都是
有共识的，自然数表示什么，实数是什么，这在讨论的人群是通常都有共识。但一个逻辑
定义的概念是什么，其实很难有共识。

想象一下，“线程”是什么？内核线程算不算线程？线程和线程间的调度代码算不算线程？
线程触发的信号处理向量算不算线程，执行线程的时候临时切换一下堆栈指针算不算线程？
实现线程的那些静态的代码算不算线程？……

要让线程有“共识”，比数学中互相共识“自然数”，难得多。但这个问题虽然麻烦，但很多
时候我们还是可以在某种程度上达成共识的。只要你不要强求“精确”（精确这个问题，我
后面专门来讨论）。

这个问题更麻烦的一个地方是在信息上分清楚名字的“名字”和“名字的内容”这两部分信息
。当我们提出“猫”这个概念，我们觉得我们说了一只有毛，有尾巴，能抓老鼠的四条腿的
哺乳动物。但如果从信息论的角度来说。猫这个字上可没有毛，也没有尾巴。

这样就导致我们在沟通上会产生混乱，我们觉得我们说了猫这个字，有时仅仅就是这个字
本身的意思，有时又觉得，我们包含了这个名字背后代表的所有东西。

所以，逻辑哲学论里，引入了这样一个概念解决这个问题：

        | proposition contains the form, but not the content of its sense. 
        | （3.1 3）

请看看我下面这个（组合）命题：

        | 由于猫喜欢吃老鼠，所以把猫和老鼠关在同一个笼子中，老鼠可能被猫吃掉。

按逻辑哲学论的定义，在这个命题中，猫只有一个属性：喜欢吃老鼠。不包含它有四条腿，
有尾巴，是哺乳动物这些信息。

在这个命题中，明说的：猫，猫喜欢吃老鼠；和没有明说的：猫比老鼠强大，都是这个命
题的一部分，但猫是四条腿的，这不是命题的一部分。

对应到我们定义的逻辑闭包中，我们的封闭空间中只包含了猫喜欢吃老鼠和猫比老鼠强大
这些信息，不包含猫是四条腿的信息。你来问我：猫难道不是四条腿的？我的回答是，在
我的逻辑闭包中，我不知道，也不关心，猫是否有四条腿。它是不是有四条腿，都不改变
它有机会把老鼠吃掉这个命题。

这个约束，才是逻辑闭包这个定义最核心的地方。我们做架构设计是为什么？是我们要“抽
象”我们的目标系统。如果我们的抽象包含了目标系统的所有信息，这就不是抽象了。而我
们抽象又是为了什么？就是我们可以具体这些抽象进行“推理”，证明某些结论是可以成立
的，所以，我们需要点清我们把什么信息放进了一个逻辑闭包，然后把对这些信息进行逻辑
推理，最终在推理中证明我们的目标是可以成立了。

所以，本质上逻辑闭包就是建模，每个模型，都是一个独立的逻辑闭包，证明某个结论，这些
结论，为我们进行下一级设计，乃至最终编码，提供约束，使我们设计每个逻辑闭包的时候都
面对有限的概念，可以进行完整的推理。

考虑一个简单的Hello World程序：

.. code-block::C

   #include <stdio.h>
   #include <stdlib.h>

   int main(void) {
     printf("Hello World\n");
     return EXIT_SUCCESS;
   }

这一段简单的代码就构成一个逻辑闭包。这个闭包包括这样一些定义：

1. main函数是整个程序的入口，它的返回值决定程序的返回值
2. 程序正常返回应该返回EXIT_SUCCESS
3. printf可以让程序输出一个字符串，我们按要求输出了"Hello World\n"
4. printf和EXIT_SUCCESS由stdio.h和stdlib.h定义
5. ……

但它不包含这些信息：

1. stdio.h中定义了ssize_t
2. printf实际上就是puts
3. EXIT_SUCCESS等于0
4. ……

你说EXIT_SUCCESS是不是等于0呢？很多平台上是，但我们这个闭包不关心，不在乎这一点
。正因为它不在乎这一点，所以它的复杂度才不高，所以它才能够复用。多一个关联，它就
多一个限制。比如，你把程序写成这样看看？：

.. code-block::C

   #include <stdio.h>
   #include <stdlib.h>

   #ifndef ssize_t
   # error Haaa... where my ssize_t, give me back.
   #endif

   int main(void) {
     if (EXIT_SUCCSS==0)
       printf("Hello World\n");
     return EXIT_SUCCESS;
   }

（这个语法不完全对，反正就这意思吧。）

这就不再是原来的概念空间了，它的复用能力，可维护性也完全不如原来的定义了。

学习架构设计，最怕的是抽象太像代码了。人们会把抽象当成是代码本身，就好像有些人
学习UML，就想着用UML来编码，这就完全误会架构设计的目的了。所以，允许我再举一个
抽象更高的例子。

还是前面这个Hello World程序，我现在需要用最快的速度输出100个Hello World。怎么做
是最快的？下面是一个对这个问题的闭包设计：

        | 根据对目标系统的Profile分析，打印的瓶颈在于字符串编码为tty控制台命令
        | 的时间太长，编码过程占整个执行过程的99.99%，而我们有十个CPU，所以要最
        | 快打印100个字符串的方法是创建10个线程，每个打印10个，就可能用最快的速度
        | 打印。

这个定义和代码完全没有关系，是不是用C语言写的我们也不关心，我们这个空间中，只抽
象这些概念：

1. 目标系统编码时间很长，占整个执行过程的99.99%
2. 我们有10个CPU
3. 操作系统调度器，会自动把多个进程分布到不同的CPU上
4. ……

这些概念你可以不同意，但这不影响它构成一个独立的逻辑闭包。而能让你不同意，恰恰
是建立这个逻辑闭包的目的。比如说，我们可以先反对你已经提出的这些概念的结论，比
如：

1. 你这个目标系统的编码时间测试有问题，你用的不是我们的主流平台，在主流平台上，
   这只是80%。
2. 我们的程序可不只跑在这个平台上，我们的平台的CPU的数量是个变量n，（n在1-128范围内）
3. 我们用的OS，如果你不主动调度，有些是只在CPU0上调度的
4. ……

不要紧，因为这个逻辑闭包是经过化简的，所以可能可以把它换成这样：

        | 根据对目标系统的Profile分析，打印的瓶颈在于字符串编码为tty控制台命令
        | 的时间太长，编码过程占整个执行过程的80%到99.99%，而我们可能有n个CPU，
        | 所以只要分成n个线程，分别绑定到不同的CPU上，分散打印，就能达成目的。

我们就可以在这个基础上继续完善我们的逻辑闭包了。

除了质疑闭包集合的元素，你同样可以质疑推理过程，比如你可以说：分散打印其实是有
问题的，这样不同的打印会交叉在一起，出现在tty上的就不是一个个独立的Hello World
了。如果我们的共识是承认这个质疑成立，我们一样需要优化这个推理，让结论成立。比如
我们可能需要把打印的过程分成“编码”和“输出”两个阶段。这个闭包的名字空间就变大了。
在我们的抽象中，原来是看不见“编码”和“输出”两个过程的，都被抽象为“打印”了。但如果
这个空间的逻辑推理无法成立，那么我们就需要看到它，那这个下一层的“名字的内容”，就
成为本闭包信息集合的一部分。

.. note::

   《道德经》里有一种说法，叫“不为天下先”，又叫“不敢为主而为客”，说的就是这里的
   策略：我们定义一个逻辑空间的时候，尽量不加入新的概念，直到我们的推理碰到了障
   碍，我们被动要把概念从下一层提上来，这会让我们的逻辑闭包更复杂，但这是没有办
   法的事情。设计的目标恰好是这个：我们希望在能达成目标的情况下，最大程度化简系
   统。功能性能是我们的目标，化简同样是我们的目标，我们需要两者同时成立，就有了
   权衡的动力。整个设计的目的，就是为了这个权衡。

在实践中，我发现在复杂设计中，最容易出问题的是这个推理，因为细节是无限大的，你
可以抽任何细节上来当作是抽象（抽象其实是用某个细节来“代表”整体）。比如前面这个
推理如果写成这样：

        | 根据对目标系统的Profile分析，打印的瓶颈在于字符串编码为tty控制台命令
        | 的时间太长，整个printf居然用了3分钟，而我们可能有n个CPU，这些CPU都是
        | 5nm的工艺加工的，成本同比达到其他CPU的2倍，所以我们要多用一些CPU打印，
        | 问题就可以解决了。

这种，你说它不对呢，每句话都是对的，但这个推理就是没有意义的。我这里写得很荒谬
，而且只有一小段，所以还是能一眼看出来，但如果这些内容分布在十几页的文档中，就
很难说了。

所以，其实说起来，我们是不希望一个逻辑闭包横跨十几页的。我们需要每个闭包在一两
页中就能独立成形。就好像写程序一样，我们希望一个函数一两百行，不希望设计上千行
的函数，因为人脑根本就没有办法，连续处理那么长的逻辑链。所以，如果你定义一个逻
辑闭包，却不断需要从几十页外拿另一个设计定义出来说：你看，我这里说过了。那你这
个肯定就不是个闭包。我们分解闭包，就是为了正交地分解每个独立逻辑，让每个封闭空
间和其他空间只有少数的关联。这样整个系统仍是可推理的，而不是横跨十几页。

严格来说，横跨十几页，这十几页的信息，共同构成一个无法思考的逻辑闭包。那么我们
应该要求你创建更小的闭包去抽象它。

设想一下4+1视图。你的代码很多，说不定是十几万行代码，你怎么“思考”这个代码符合你
的预期？4+1视图就是一种分类方法，比如开发视图，我们不管运行的时候有多少类，不管
创建了多少线程，也不管分发到多少节点上，我们从“开发”这个角度来抽象它：我们分成
多少个源代码目录？编译出多少个exe文件？我们从这个角度来单独建模它的组织。这就简
单多了吧？

然后我们换到部署视图，我们单独谈把不同的exe跑多少个instance到不同的计算机上，分
别创建什么通讯端口，这也简单多了吧？

但我们仍需要一个“目标”去保证我们的推理。这就是那个1了，我们有Use Case图，在那个
图里面，我们说，我们需要让用户看到一个前端。这样我们就可以把这个目标落到我们的
开发视图上了：你哪个目录上的文件可以搞定这个前端？

再落到部署视图上：那个节点负责运行这个前端？它是否有通讯通道获得它需要的那些信
息？

如此类推。

整个设计，最终就是不同层次，不同角度的，一个个收缩得最小，让人脑可以校验的封闭
空间。设计，架构设计，这些设计的本质，就是大量逻辑闭包的设计。

关于逻辑闭包概念和命题的精确性问题
==================================

按逻辑哲学论，What can be said at all can be said clearly, and what we cannot
talk about we must pass over in silence。所以，Can be said的，就是精确的，而we
cannot talk的，就是模糊的，只能pass over in silence。

在逻辑闭包的定义中，我们说下的每个判断，如果可以用于进行真值判断（选择其中一个
结论），这些都可以认为是精确的。猫，精确吗？不精确，波斯猫是不是猫？咖菲猫是不
是猫？猫会抓老鼠，精不精确？所有猫都抓老鼠吗？不见得吧？

但在逻辑闭包中，我们放进去的都是共识（你可以不同意，并且清晰地反对它），但在这
个封闭的空间中，它就是精确的，有明确的判断标准。这是“数字化”的本意，一个数字化
的wav文件能明确代表一段模拟信号吗？不能，但一旦数字化，它就是精确的，1等于1,
1不等于2，这些都有明确的判断标准。

所以，逻辑闭包中的定义就是精确的，猫就是可以抓老鼠，如果定义猫部分可以抓老鼠，
这句话也是精确的。你们可以在pass over insilence中讨论这个定义的结果是false，但
这个定义本身是精确的。如果你承认它，那么就意味着，它可以覆盖你在其他地方使用它
时的所有语义范围，而不能是我在这个逻辑闭包中就这么说说，换一个逻辑闭包的定义和
原来不同。一旦这样，这个设计也就不成立了。你可以覆盖很大的一个范围，比如你说，“
中断，是中断收集器上在某个时刻检测到的一次事件”，这很模糊，但它确实可以覆盖所有
什么电平中断，边缘触发中断，消息中断。这就是精确的。但你不能说，“中断，就是某条
引线上的电平变化”。这不覆盖所有的情况，除非你认为你的定义空间中，就只有这种中断。
你不能在另一个地方突然插入一个消息中断，然后引用你前面获得的那些结论。

有人可能会犯这样的错误：他们看到一个定义的范围很模糊，他觉得架构定义可能就是可
以不那么严格的（反正又不是可以跑的代码），在这种问题上就不那么在乎，觉得这不重
要。但我们必须搞清楚，范围模糊，只是定义的范围很大（这在逻辑哲学论中称为“Truth
Posibility”，有可能对的所有可能性），不是不精确，范围大，我们就在这个大的范围中
对所有的可能性进行推理，这个推理过程本身是严密和精确的。
