.. Kenneth Lee 版权所有 2022

:Authors: Kenneth Lee
:Version: 1.0
:Date: 2022-03-06
:Status: Released

逻辑闭包V2
**********

介绍
====

本文是我关于逻辑闭包定义的一个新的版本。

我原来写过另一个版本，在这里：\ :doc:`逻辑闭包`\ 。因为不断补充逻辑，那个版本的
组织已经变得很松散了，新的版本我尝试综合这些松散的信息，写一个逻辑上更聚焦的版
本，但原来的逻辑我又舍不得丢弃。所以，那个版本我会继续维护，大部分信息都会放在
那个版本上，这个版本作为一个真正的Release，作为一个“标准的定义”来使用。

定义
====

“逻辑闭包”这个定义是我所有架构设计概念和方法的基础，没有这个基础，我们就无法讨
论其他设计方法。我个人也认为它是所有设计方法的理论基础，是否承认，就看你自己看
过我的观点后任何认知了。

“Logical Closure”（逻辑闭包），这个概念是我为了说明问题而创造的，也许别的理论有
其他的名称。它最初来自数学中Closure的定义：

        | In mathematics, closure describes the case when the results
        | of a mathematical operation are always defined.
        |
        |                                       -- Wikipedia

它描述的其实是一个计算系统，包括一个集合和一组对于这个集合的计算方法。比如，自
然数配合加法，就构成一个闭包：自然数构成一个集合，在这个集合中任选两个元素，经
过加法计算以后，结果还是在自然数这个集合中。

同理，分数这个集合，加上加减乘除这些运算，也构成一个闭包。

我们把这个概念引入到逻辑推理中：如果我们引入了一组定义，如果用这一组定义进行逻
辑推理，这个推理的结果仍在这组定义中，那么，我们就认为我们这个推理，构成一个逻
辑闭包。

定义的内涵本身很简单，但其实这个问题比数学上的问题复杂得多。因为数学系统的概念
基本上都是有共识的，自然数表示什么，实数是什么，这在讨论的人群有共同的认知。但
一个逻辑定义的概念是什么，其实很难有共识。

想象一下，“线程”是什么？内核线程算不算线程？线程和线程间的调度代码算不算线程？
线程触发的信号处理向量算不算线程，执行线程的时候临时切换一下堆栈指针算不算线程？
实现线程的那些静态的代码算不算线程？……

要让线程有“共识”，比数学中互相共识“自然数”，难得多。但这个问题虽然麻烦，但很多
时候我们还是可以在某种程度上达成共识的。只要你不要强求世俗的“精确”（精确这个问
题，我后面专门讨论）。

我们这些首先解决一个更麻烦的问题：如何分清楚我们提到的一个名字的“名字本身”和“名
字的内容”这两部分信息。

当我们提出“猫”这个概念，我们觉得我们说了一只有毛，有尾巴，能抓老鼠的四条腿的
哺乳动物。但如果从信息论的角度来说。猫这个字上可没有毛，也没有尾巴。

这样就导致我们在沟通上会产生混乱，我们觉得我们说了猫这个字，有时仅仅就是这个字
本身的意思，有时又觉得，我们包含了这个名字背后代表的所有东西。

所以，逻辑哲学论里，引入了这样一个概念解决这个问题：

        | 3.1 3 proposition contains the form, but not the content of its
        | sense. 
        |
        |                          -- Tractatus Logico-Philosophicsu

请看看我下面这个（组合）命题：

        | 由于猫喜欢吃老鼠，所以把猫和老鼠关在同一个笼子中，老鼠可能被猫吃掉。

按逻辑哲学论的定义，在这个命题中，猫只有一个属性：喜欢吃老鼠。不包含它有四条腿，
有尾巴，是哺乳动物这些信息。

在这个命题中，明说的：猫，猫喜欢吃老鼠；和没有明说的：猫比老鼠强大，都是这个命
题的一部分，但猫是四条腿的，这不是命题的一部分。

对应到我们定义的逻辑闭包中，在这个“封闭空间”中只包含了猫喜欢吃老鼠和猫比老鼠强
大这些信息，不包含猫是四条腿的信息。你来问我：猫难道不是四条腿的？我的回答是，
在我的逻辑闭包中，我不知道，也不关心，猫是否有四条腿。它是不是有四条腿，都不改
变它有机会把老鼠吃掉这个命题。

这个约束，才是逻辑闭包这个定义最核心的地方。我们做架构设计是为了什么？是我们要“
抽象”我们的目标系统。如果我们的抽象包含了目标系统的所有信息，这就不是抽象了。而
我们抽象又是为了什么？就是我们可以根据这些抽象进行“推理”，证明某些结论是可以成
立的，所以，我们需要点清我们把什么信息放进了一个逻辑闭包，然后把对这些信息进行
逻辑推理，最终在推理中证明我们的目标是可以成立的。

所以，本质上逻辑闭包就是建模，每个模型，都是一个独立的逻辑闭包，证明某个结论，
这些结论，为我们进行下一级设计，乃至最终编码，提供约束，使我们设计每个逻辑闭包
的时候都面对有限的概念，可以进行完整的推理。

考虑一个简单的Hello World程序：

.. code-block::C

   #include <stdio.h>
   #include <stdlib.h>

   int main(void) {
     printf("Hello World\n");
     return EXIT_SUCCESS;
   }

这一段简单的代码就构成一个逻辑闭包。这个闭包包括这样一些定义：

1. main函数是整个程序的入口，它的返回值决定程序的返回值。
2. 程序正常返回应该返回EXIT_SUCCESS。
3. printf可以让程序输出一个字符串，我们按要求输出了"Hello World"
4. printf和EXIT_SUCCESS由stdio.h和stdlib.h定义
5. ……

但它不包含这些信息：

1. stdio.h中定义了ssize_t
2. printf实际上就是puts
3. EXIT_SUCCESS等于0
4. ……

你说EXIT_SUCCESS是不是等于0呢？很多平台上是，但我们这个闭包不关心，不在乎这一点
。正因为它不在乎这一点，所以它的复杂度才不高，所以它才能够复用。多一个关联，它
就多一个限制。比如，你把程序写成这样：

.. code-block::C

   #include <stdio.h>
   #include <stdlib.h>

   #ifndef ssize_t
   # error Haaa... where my ssize_t, give me back.
   #endif

   int main(void) {
     if (EXIT_SUCCSS==0)
       printf("Hello World\n");
     return EXIT_SUCCESS;
   }

（这个语法不完全对，反正就这意思吧。）

这就不再是原来的概念空间了，它的复用能力，可维护性也完全不如原来的定义了。

所以，逻辑闭包强调的是信息封锁在一个空间之内，让我们总能看到。

学习架构设计，最怕的是抽象太像代码了。人们会把抽象当成是代码本身。就好像有些人
学习UML，就想着用UML来编码，这就完全误会架构设计的目的了。所以，允许我再举一个
抽象更高的例子来说明这个问题。

还是前面这个Hello World程序，我现在需要用短的时间输出100个Hello World。应该怎么
设计？下面是一个对这个问题的闭包设计：

        | 根据对目标系统的Profile分析，打印的瓶颈在于字符串编码为tty控制台命令
        | 的时间太长，编码过程占整个执行过程的99%，而我们有十个CPU，所以只要把
        | 打印分散到10个线程或者进程中，每个打印10个，这样的时间就是最短的。

这个定义和代码完全没有关系，是不是用C语言写的我们也不关心，我们这个空间中，只抽
象这些概念：

1. 目标系统编码时间很长，占整个执行过程的99.99%
2. 我们有10个CPU
3. 操作系统调度器，会自动把多个进程分布到不同的CPU上
4. ……

这些概念你可以不同意，但这不影响它构成一个独立的逻辑闭包。而能让你不同意，恰恰
是建立这个逻辑闭包的目的。因为这样我们就有一个有限的空间让我们评估我们的判断是
不是合理的：比如我们可以这样质疑这个定义空间：

1. 你这个目标系统的编码时间测试有问题，你用的不是我们的主流平台，在主流平台上，
   这只是80%。
2. 我们的程序可不只跑在这个平台上，我们的平台的CPU的数量是个变量n，（n在1-128范
   围内）。
3. 我们用的OS，如果你不主动调度，有些是只在CPU0上调度的。
4. ……

不要紧，因为这个逻辑闭包是经过化简的，所以可能可以把它换成这样：

        | 根据对目标系统的Profile分析，打印的瓶颈在于字符串编码为tty控制台命令
        | 的时间太长，编码过程占整个执行过程的80%到99.99%，而我们可能有n个CPU，
        | 所以只要分成n个线程，分别绑定到不同的CPU上，分散打印，就能达成目的。

我们就可以在这个基础上继续完善我们的逻辑闭包了。

除了质疑闭包集合的元素，你同样可以质疑推理过程，比如你可以说：分散打印其实是有
问题的，这样不同的打印会交叉在一起，出现在tty上的就不是一个个独立的Hello World
了。如果我们的共识是承认这个质疑成立，我们一样可以优化这个推理，让结论成立。比
如我们可能需要把打印的过程分成“编码”和“输出”两个阶段。这个闭包的名字空间就变大
了。在我们的抽象中，原来是看不见“编码”和“输出”两个过程的，都被抽象为“打印”了。
但如果这个空间的逻辑推理无法成立，那么我们就需要看到它，那这个下一层的“名字的内
容”，就成为本闭包信息集合的一部分。

.. note::

   《道德经》里有一种说法，叫“不为天下先”，又叫“不敢为主而为客”，说的就是这里的
   策略：我们定义一个逻辑空间的时候，尽量不加入新的概念，直到我们的推理碰到了障
   碍，我们被动要把概念从下一层提上来，这会让我们的逻辑闭包更复杂，但这是没有办
   法的事情。设计的目标恰好是这个：我们希望在能达成目标的情况下，最大程度化简系
   统。功能性能是我们的目标，化简同样是我们的目标，我们需要两者同时成立，就有了
   权衡的动力。整个设计的目的，就是为了这个权衡。

在实践中，我发现在复杂设计中，最容易出问题的是这个推理，因为细节是无限大的，你
可以抽任何细节上来当作是抽象（抽象的本质是用某个细节来“代表”整体）。比如前面这
个推理如果写成这样：

        | 根据对目标系统的Profile分析，打印的瓶颈在于字符串编码为tty控制台命令
        | 的时间太长，整个printf居然用了3分钟，而我们可能有n个CPU，这些CPU都是
        | 5nm的工艺加工的，成本同比达到其他CPU的2倍，所以我们要多用一些CPU打印，
        | 问题就可以解决了。

这种，你说它不对呢，每句话都是对的，但这个推理就是没有意义的。我这里写得很荒谬
，而且只有一小段，所以还是能一眼看出来，但如果这些内容分布在十几页的文档中，就
很难说了。

所以，其实说起来，我们是不希望一个逻辑闭包横跨十几页的。我们需要每个闭包在一两
页中就能独立成形。就好像写程序一样，我们希望一个函数一两百行，不希望设计上千行
的函数，因为人脑根本就没有办法，连续处理那么长的逻辑链。所以，如果你定义一个逻
辑闭包，却不断需要从几十页外拿另一个设计定义出来说：你看，我这里说过了。那你这
个肯定就不是个闭包。我们分解闭包，就是为了正交地分解每个独立逻辑，让每个封闭空
间和其他空间只有少数的关联。这样整个系统仍是可推理的，而不是横跨十几页。

严格来说，横跨十几页，这十几页的信息，共同构成一个无法思考的封闭空间。我把这称
为一个“黑盒”，表示一个无法校验的，我只能无条件认为它正确的一个“名称”。前面例子
中这个黑盒，我只能得到这么一个信息“这个问题可以解决”，它是否最终成了，就看我们
对作出判断的那个人自己的可信度了。

黑盒不是设计，黑盒是无条件成立的一种“信任”，就好像前面正面的例子中，我们信任“打
印的瓶颈是tty编码”，“OS能调度线程和进程”一样。它是闭包的“原子元素”（概念来自逻
辑哲学论的Atomic Proposition）。

所以，如果你的封闭空间太大，我们就需要要求你创建更小的闭包去抽象它。这是我们不能
直接编码而需要进行设计的理由。

设想一下4+1视图。你的代码很多，说不定是十几万行代码，你怎么“思考”这个代码符合你
的预期？4+1视图就是一种分类方法，比如开发视图，我们不管运行的时候有多少类，不管
创建了多少线程，也不管分发到多少节点上，我们从“开发”这个角度来抽象它：我们分成
多少个源代码目录？编译出多少个exe文件？我们从这个角度来单独建模它的组织。这就简
单多了吧？

然后我们换到部署视图，我们单独谈把不同的exe跑多少个instance到不同的计算机上，分
别创建什么通讯端口，这也简单多了吧？

其他视图同理，每个视图本身，还可以分层。

但所有这些要进行推理，我们需要一个“目标”去保证我们的推理，这就是那个1了。我们有
Use Case图。比如，在那个图里面，我们说，“我们需要让用户看到一个前端”。这样我们
就可以把这个目标落到我们的开发视图上了：你说你需要一个前端，为什么你的代码里面
看不见前端的代码？这个代码在哪里？

再落到部署视图上：哪个节点负责运行这个前端？它是否有通讯通道获得它需要的那些信
息？

如此类推。

整个设计，最终就是不同层次，不同角度的，一个个收缩得最小，让人脑可以校验的封闭
空间。设计，架构设计，这些设计的本质，就是大量逻辑闭包的设计。每个闭包抽象出来
的名字，有成为其他闭包的原子命题来使用。

精确性问题
==========

精确性问题是理解逻辑闭包思想一个非常关键的哲学问题，我们在这里单独讨论它。

按逻辑哲学论：

        | What can be said at all can be said clearly, and what we cannot
        | talk about we must pass over in silence。
        |
        |                          -- Tractatus Logico-Philosophicsu

所以，Can be said的，就是精确的，是Clear的。而we cannot talk的，就是模糊的，只
能pass over in silence的。

在逻辑闭包的定义中，我们说下的每个判断，如果可以用于进行真值判断（选择其中一个
结论），这些都可以认为是精确的。猫，精确吗？不精确，波斯猫是不是猫？咖菲猫是不
是猫？猫会抓老鼠，精不精确？所有猫都抓老鼠吗？不见得吧？

但在逻辑闭包中，我们放进去的都是共识（你可以不同意，并且清晰地反对它），但在这
个封闭的空间中，它就是精确的，有明确的判断标准。这是“数字化”的本意，一个数字化
的wav文件能明确代表一段模拟信号吗？不能，但一旦数字化。它就是精确的，1等于1, 1
不等于2，这些都有明确的判断标准。

所以，逻辑闭包中的定义就是精确的，猫就是可以抓老鼠，如果定义猫部分可以抓老鼠，
这句话也是精确的。你们可以在pass over insilence中觉得这个定义的结果是false，但
这个定义本身是精确的。如果你承认它，那么就意味着，它可以覆盖你在其他地方使用它
时的所有语义范围，而不能是我在这个逻辑闭包中就这么说说，换一个逻辑闭包的定义和
原来不同。一旦这样，这个设计也就不成立了。你可以覆盖很大的一个范围，比如你说，
“中断，是中断收集器上在某个时刻检测到的一次事件”，这很模糊，但它确实可以覆盖所
有什么电平中断，边缘触发中断，消息中断。这就是精确的。但你不能说，“中断，就是某
条中断引线上的电平变化”。这不覆盖所有的情况，除非你认为你的定义空间中，就只有这
种中断。你不能在另一个地方突然插入一个消息中断，然后引用你前面获得的那些结论。

我们很多人容易把“精细”，理解成了“精确”了。因为我们确实会说，1mm刻度的尺子比1cm
刻度的“精确度”更高。但在逻辑上，我们关心的是集合，如果我们的判断模型中，可以明确
给出A在集合中，或者不在集合中，那么，我们就认为这个判断是“精确”的。

我们可以写一个每日打卡程序吗？“这种程序以前写过，我们团队有10个人，只要提供足够
的服务器，应该可以”。这些话很模糊，但在逻辑上，它是严格的，因为它输出一个结论：
“可以”。你不要看它说什么“应该可以”，也不要管“以前写过的程序和现在的程序不一定相
同”，它用一定的信息，作出了一定的判断，结论是唯一的，这就是精确。你可以质疑它的
原子命题本身的真假，但那个没有逻辑判断在里面，那个是Pass over in silence的。那
个没得争的，你说是就是，我们互相不同意，就只能用其他手段说话（当然包括打开它下
一层的逻辑），这是辩论的终点。

模糊只是扩大了可能性边界而已。我们说“猫可以抓老鼠”，这对猫和抓老鼠的定义都很模
糊，但就算我们收缩了猫的范围，我们说的也是一个可能性，在某只猫抓到某只老鼠前，
这都只是可能性，我们本来就是定义一个可能性的范围，而不是在描述一个事实。这在逻
辑哲学论中称为“Truth Posibility”，表示我们只是设定了一个“有可能变成事实的所有
可能性的集合”。

所以，也许我们现在更容易理解为什么设计的本质就是逻辑闭包了：

我们对确切性的感知，都来自我们进行逻辑推理时把分类条件确切化了。你看到一个大汉
，你觉得他“很能打”。这个推理过程其实是Pass Over In Silence的。为什么你觉得他很
能打，你的判断条件其实是可以找出来的，比如你是通过这三个条件找到的：

1. 他比你高，看起来有2米
2. 你过桥的时候桥在震动，说明他很重
3. 他的面相很像电影里很能打的人的样子

换一个人判断，可能他会得出完全相反的结论，因为他取的条件和你不同：

1. 他脸色苍白，明显刚病好
2. 他很重，大肚腩，缺乏锻炼
3. 他走路的样子不沉稳，明显没有练过

你看，我们进行技术判断，希望我们的判断是有逻辑的，其实就是把我们Pass Over In
Silence得到的结论，减少黑盒，用更多的逻辑推理取代Pass Over In Silence的Atomic
Proposition。这其中，逻辑闭包起了最大的作用，因为只有一个逻辑闭包的完整的，我们
可以看到所有的条件，也看到用这些条件运算的到的结论符合集合运算的条件了。我们才
会认为我们进行了一个“理智的判断”。

而没有逻辑闭包，我们看到的就是“黑盒”，我们只能考虑“信任”，还是“不信任”你。
