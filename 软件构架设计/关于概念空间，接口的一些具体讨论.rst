.. Kenneth Lee 版权所有 2021

:Authors: Kenneth Lee
:Version: 1.0

关于概念空间，接口的一些具体讨论
********************************

本文没有什么新的总结，只是根据最近的一些工作，记录一些细节讨论，增强已经总结的
一些概念。

在这之前，我想再解释一下什么是抽象和名称空间。比如说，我在你身上挂一个传感器，
连续记录你的垂直运动位置。这样记录一年，我就可以拿到一个很详细的波形图。现在的
问题是：这是否在描述你？

在一般的理解意义上，这当然是在描述你。因为按我们一般人的理解，你就是这个波形图
的原因，因为你主动的运动，所以我们才有了这幅图。但为什么你某天突然一下子在一分
钟内垂直升高100米？这个原因不见得就是你，这个原因可能是电梯。

这里我们想强调的是，我们看待一个事情，永远都是看到它的一个呈现，这个呈现的原因
，也永远都是基于综合的作用的，所以描述什么，以及描述什么的原因，只是一个度的问
题。

现在我们再在你身上装另一个传感器，记录你的水平运动轨迹，记录一年，我们又有了一
个图，这个图同样也是在描述你。那么，到底是水平传感器的记录是你，还是说垂直传感
器的记录是你呢？如果我们再加上温度传感器，血压传感器，不同地方血管的血压传感器
，你身边十厘米处风速传感器，你10米内人数传感器，你五米内动物的数量传感器，你所
在的城市的传感器……等等等等，这些是否也在描述你呢？

好了，通过这个例子，我们至少认清楚了一点：我们描述任何人的某个方面，都是描述这
个人，但永远都不是在描述这个人的全部。当我们的思路被拉到某组相关数据去的时候，
我们的逻辑就全部都在这些数据上，我们丢弃了其他逻辑，但也正因为我们丢弃了其他逻
辑，所以我们才看清了某个“角度”的逻辑。这个单独讨论某个角度的数据的名称的因果关
系描述，就是我们说的“概念空间”，或者“逻辑视图”，或者简单说，“视图”，“View”。

视图，只是我们寻找相关性的一种方法，而且，在我的认识中，它可能是唯一的方法。但
它的缺陷也非常明显，就是它不一定表示全部信息，也不一定是最好的相关性。你用概念
视图，开发视图，运行视图去描述一个系统，它不见得就能最好地控制这个系统的发展。

名字，你可以无限定义，都有可能说得头头是道，但离开了对现实的控制，它只能变成“艺
术”。在我们看电影的时候，很多时候一些电影情节逻辑上是说不通的，但我们仍被其他细
节所吸引，我们仍把它看做是真实去看待它。这是因为电影本身，完全是人脑中的存在，
是纯粹的“名称空间”，它没有逻辑性是可以的（当然，不能太过分，否则它会被人脑对逻
辑的天然美好追求所抛弃）。

但架构设计不行，因为架构设计的目标是落地，它建的逻辑，无论抽象到多高，最终都是
要被实施的。

这就是这里要说的第二个问题：每层抽象都是被下层的逻辑直接影响的。比如说你做一个
芯片吧，你会选择一种指令集，比如加法叫add，乘法叫mul。你再做一个指令集，加法叫
great_add，乘法great_mul，这其实关系不大，这仅仅是一个名字的改变。这在逻辑空间
中是最轻度的变化。但如果这两个算法的内涵是不同的，比如，第一个add的定义是这样的
：::

        add rs1, rs2, rd
                add rs1, rs2 and flag.carried to rd

而第二个great_add的定义是这样的：::

        great_add condition, rs1, rs2, [rd]
                if confition flag equal to global flags.c, add rs1 and rs2 and
                place the result in the 8 byte memory poited by rd in flags.e
                endian format.

这就定义了两个很不一样的名称空间。

请认真思考一下这两个例子。两个指令都为芯片的实现提供了一个高层约束，我不管你用
电子管，还是用晶体管，甚至用量子计算那些复杂的概率波理论来实现这个约束。你会有
你细节的约束，但你只要要实现这个接口，这个接口就约束了你必须有构架寄存器
r1...rN，要有flags.carried。我也不管你这些rX到底表达为RegFile的一个rename，还是
表现为概率云的某个编码中的一段，你内在的逻辑中就必须保证我给你两个寄存器的时候，
你给我在rd中放上rs1+rs2+flag.carried这个结果。为了保证这一点，你必须实现你的逻
辑，让这个“高层逻辑”成立。

同样的，你用一样的约束，如果实现的是great_add，你的内在逻辑需要有很大的改变，因
为两个逻辑空间要认知的东西是不一样的。虽然下面的约束还是这些电子管的导通和截断
，晶体管的饱和区和截止区的变化。但你在这个基础上要模拟的抽象实体不同，它会需要
不同的逻辑组织。

当然，因为这两个逻辑空间有一个很大的东西是一致的（比如加法本身），这两个指令确实
有不少地方是可以合并的。从一个算法切换到另一个算法中也是比较容易的。但如果一开始
就要求“兼容”两套算法。这个设计难度就会完全不同，比如，我们在逻辑上可能需要这样
合并它们：::

        common_add condition, rs1, rs2, rd, is_great
                a1=rs1
                a2=rs2
                a3=a1+a2
                if is_great:
                        if flags.c==condition:
                                set_mem8_as_endian(flags.e, rd, a3)

                else:        
                        a3+=flag.carried
                        rd = a3

还是那句话，我也不管你细节上实现在什么东西上，也不管你把下面分多少层，这个逻辑
都是横亘在你的整个逻辑空间中的，你怎么都逃不过去，玩什么“这部分放软件上，那部分
放硬件上，那个计算合并在DDRC中……”，都白搭，最后这个逻辑都是要被满足的。

所以，你不能把这些东西推给细节逻辑。高以下为基，确定了高层逻辑，下一层逻辑就被
限制得死死的。我们用高层逻辑去约束细节逻辑，而用细节逻辑去挑战高层逻辑，都是为
了用逻辑去丈量我们的目标是否是可以走通的。你可以用细节逻辑去证明高层逻辑不可行
，但不能用细节逻辑去证明高层逻辑可行。你也可以用高层逻辑去约束细节逻辑，但你不
能高层设计去证明细节设计“可行”。我们只是基于目标去建造一个对细节约束最小的逻辑
，然后一路向前探路，希望我们最终可以到达目标而已。

而动不动做“通用设计”，多接口兼容，就是提前收缩自己自由空间，增加自己失败的可能
性。
