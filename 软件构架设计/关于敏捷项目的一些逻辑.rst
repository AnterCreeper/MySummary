.. Kenneth Lee 版权所有 2021

:Authors: Kenneth Lee
:Version: 1.0
:Date: 2021-12-25
:Status: Draft

关于敏捷项目的一些逻辑
**********************

最近大项目在一个子项目上遇到一些障碍，我下去直接带了一下项目执行。我很久没有去
具体带项目了，看到不少人执行敏捷项目上的问题，我把这些杂七杂八的问题通过本文记
录一下。

一些组织实施敏捷项目，就实施了个样子，站会，代码代替文档，Story驱动，测试驱动……
好像做了这些形式，就是在做敏捷了。

我对此不以为然。敏捷的驱动力其实就一个：软件变大以后信息不足成为主要问题。

八十年代的时候，我们做一个软件，除了最核心的需求，全部是自己的判断空间。所以我
们可以分层设计，建立第一层逻辑，基于第一层逻辑设计第二层逻辑，只要高层设计没有
明显的问题，下面遇到的障碍是有限的，要打印就要自己写一个printf的库，要排序就自
己写排序算法，要用链表就创建链表。就算有一些开发库，也是用相对标准的，Posix，
STL等等，这可以支撑你做瀑布模型。

但现在不行了，你下面一堆的库和框架，你用Log4J吗？你用glib-thread吗？你用
tensorflow-2.0吗？你写Linux驱动用哪个版本的内核API？全在变，你怎么做高层设计？
你要保证你的高层设计要好，就要去调查深入的底层逻辑，但这个底层逻辑隔几个月就会
变，你的用户对你做的功能的要求，也隔几个月就会变，你运筹帷幄提前想好一年内怎么
开发，毫无意义，因为提前做这个判断基本上都是错的。这种判断就好像判断明年今天会
不会下雨一样，没有判断的条件。

所以，敏捷不是不要设计，也不是站立会议，而是要动脑子。每走几步，就要重新Review
一下自己的状态，然后决定怎么改向。

所以，管敏捷项目，我们其实最重要的要求是项目组成员都要动脑，我们只能给你条件，
不能告诉你路径，不能告诉你这一步怎么走，那一步怎么走。

所以我一般不开什么站立会议，我是在项目的代码库中直接放了一个devlog的目录，每个
开发成员每天更新进展。这个进展也不是“我今天做了什么”，而是一个技术判断过程：我
今天处于项目的什么位置，所以我需要做XX，然后我技术上有如下判断：……。这种判断可
能包括一个逻辑闭包的描述，说明怎么设计的。也可能是调试一个程序的coredump记录。

这种日志有两个作用：

1. 随时随地做设计
2. 事后可以找回开发过程中的一些信息

工作日志当天离开前提交，然后我作为项目负责人的工作是每天一早回来Review一次所有
人的工作，看看项目有没有走偏，引导走偏的人回来，遇到有影响所有的人问题拉会议出
来讨论。其他人做当天的准备的时候，也一样去看看其他人的进展，据此做他的计划。这
样构成一个循环。

所以，敏捷的关键在于“敏捷”，是脑子不断在动的。不是死气层层围在一起，每个人给项
目经理汇报工作：“我昨天做了XXXX”，项目经理抽一下鞭子：“不错，好好干”，或者“这样
慢可不行啊小李，别人都在等着你呢”。这他么敏捷啥呀，和过去的项目有区别吗？

所以，敏捷也不是只写代码不写设计。它不过是无时无刻都在写设计而已。而且我们也会写
复杂的设计的，比如我们最近几个目标的技术风险看着没有了，技术方向确定了，我就开始
找人写测试计划。这就是一个设计。

测试计划这件事也有一说，有人写这种计划就真的是个计划，几号几号，完成某某测试，
几号几号，有完成另外的什么测试。这种也是充样子：你连打算怎么测都没有定呢，你怎
么知道你几号几号的就能完成这个测试？——装样子。

我不是说不需要这种计划，我这里强调的我们做敏捷，首先是实事求是，是根据现实决定
最合理的选择，如果你的工作很简单，或者时间自由度很大，你要做一个时间计划，没有
问题。但很多情况下，我们不是，不是就不能做一个样子货。

不写这种时间计划，有人会走另一个极端，那直接写一个个的测试用例咯，但他有写不出
来，因为开发还没有完成，部分细节接口还没有确定，然后他就乱“理解”了一个接口，硬
写了一个测试代码出来……你看，这样同样不实事求是，而是在表演，这同样不敏捷。

我觉得测试这个事情可以提前做，是因为我们确实有提前做的基础。比如我们做一个MCU，
使用自己的指令，具体这些指令的细节我们还没有最终定，因为在开发的过程中，我们可能
根据业务流的不断优化，修改它们的详细接口。但我们已经知道我们的MCU的主要功能，
大概有什么指令，编译器和OS是怎么样的。那我们就可以基于这种信息做个打算，我们可
以确定我们的测试目标（我们的测试主要测试什么问题）和测试策略（我们主要用什么方
式组织这个测试，为什么这个测试可以发现我们的系统的问题），甚至我们确实也可以写出
部分的测试用力，比如我们不关心我们的指令怎么写，我们可以提前构思：我们一个用例
是把n加100次，然后比较它和n乘100的结果，看两者是否对得上，我们故意填充一段代码，
跳转到跳转距离的极限，和比极限小一，和距离0的位置，看执行行为是否正确……这些都不
依赖深入的接口定义，但我们确实可以提前进行准备。这些东西，不用代码表达，但它确
实简化了我们的编码啊，而且从这个维度建模，是代码不可替代的啊。

所以说，敏捷不是不写设计，而是把代码也看作是一个设计视图，其他建模也是设计视图，
而且因为所有的视图都在变，我们尽量都放在一起管理而已。在我们的项目中，无论是开发
日志，还是设计，全部都用Sphinx来写，这样就更加看起来，全都是代码了。

但问题的关键不是这些形式，而是不断变化，不断动脑的这么一个“敏捷”地走向目标的过
程啊。

最后说一个事情，我给前面提到这位做测试计划的兄弟谈“目标和策略”的方法时，他问了
一个问题：目标和策略有什么不同？这个问题问得我一愣。

直接解释，目标是内涵，策略是总结性的外延。目标是：“我想看到软件运行我们的MCU没
有错误”，但怎样才能达成这个目的呢？你又不能把所有软件都运行一遍。

解决这个问题的方法是“外延”，我们用这个，这个，这个，还有这个方法折腾一次我们的
设计，我们就达成目标了。

而策略是对这些方法的抽象，提出一些最基本的，在我们展开成一个个个例前的高层判断
，避免遗漏，走偏和浪费而定义的范围。

这个很简单，但为什么他会有这个误会呢？我想这同样是不习惯敏捷项目的特征，敏捷项
目中，所有人存在的价值是“动脑”，是补全逻辑，所以，目标和策略是有距离的。是要输
入每个开发者自己共享的逻辑的，如果你习惯了别人把所有事情怎么干的细节都告诉你，
就容易会误会：目标和策略，是同一个东西。
