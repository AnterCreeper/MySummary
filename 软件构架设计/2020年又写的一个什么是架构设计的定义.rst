.. Kenneth Lee 版权所有 2020

:Authors: Kenneth Lee
:Version: 1.0

2020年又写的一个什么是架构设计的定义
*************************************

介绍
====
本文是在和一位兄弟沟通某个特性的架构设计策略前写的前置逻辑。


基本定义
=========
软件架构这个东西，针对不同的目标，有不同的关注点，但从比较基础的逻辑来说，是我
们要定义一组逻辑，让我们可以确认这组逻辑可以成立。做一个具象化的比喻：

比如我们要从深圳去北京，我们可以建立这样一个逻辑：

1. 先在网上定机票

2. 提前2个小时打车到深圳机场

3. 坐飞机到北京首都机场

4. 通过导航软件决定坐某条公共交通线路到北京的酒店

我们执行这个逻辑是不是一定能到北京呢？不一定，因为这依赖很多细节，比如路上堵车
，天气不好飞机不能起飞，或者干脆没有去北京的机票之类的。但你说你没有这个逻辑，
出门就向北走，能不能到得了北京呢？那大概率是不行的。

设计前面这个逻辑的过程，就是架构设计。

从这个例子中，我们看到了架构设计的几个特点：

1. 它不是事无巨细，什么都设计

2. 它的逻辑是连续的

3. 它对执行具有限制作用

这说起来很简单，只是因为例子简单，实际上一旦执行，很多人都会犯错。最常见的一个
错误就是所谓的“\ :doc:`我没错<架构设计的大忌：我没错>`\ ”。但凡“我没错”的设计，
基本上都是有错的。因为架构设计首先是一种设计，所有选择中的一个选取。去北京可以
坐飞机，也可以坐高铁，你要选其中一个，放弃另一个，放弃另一个是没有严格理由的，
只是你不能两个都选而已。你要保证“我没错”，就必须两个都选，这就没有在做架构设计
这件事情。我们有些工程师，只要市场部，领导，或者兄弟部门不签字，就不肯选择，说
到底都是这种“我没错”的思路在作怪。希望每个选择都是有严格的“理由”的，却不知道这
恰恰是最没有理由的选择。

“我没错”的另一个表现是脱离逻辑链，避开逻辑链去谈“正确的信息”，以图用信息填补没
有设计的缺陷。比如，今天之内有12班航班飞北京，其中6班要中途转机，他们的机型分别
是巴拉巴拉，这些机型的故障率用柱状图表述如下……。这看着都没有错，还很专业的样子
，但其实根本和我们要做的设计逻辑毫无关系。你说他有问题，他还给你辩解说“难道飞机
安全不重要吗？”。如果不用这么简单的例子对比，我们可能很难想象这种事情在架构讨论
中发生的频度会如此之高。比如在一个网卡的高层设计讨论中，人们会上来就讨论MAC包的
格式，这种事情居然会陈出不穷。

前面这个脱离逻辑链问题一个更加隐秘的体现是高层逻辑和下层逻辑不分。还是用前面这
个坐飞机的例子来类比。打的这个选择，可能有不同的细节可以选择，比如可以是打出租
车，也可以是用快车，专车之类的服务，这个确实也是我们必然要做的选择，但这个逻辑
的变化，不改变我们其他任何逻辑，这个东西就属于下一层的设计。我们不应该把它提到
本层里面来。这很重要，因为我们在架构设计阶段，主要目的不是为了把整个产品做出来
，而是保证高层逻辑合理了，我们可以专心根据高层逻辑的来做下层逻辑的设计，所以我
们必须全部心思反复权衡高层逻辑是不是最优的，有没有优化的余地，有没有多余的约束
。高层逻辑引入的约束越少，我们做下层设计的自由度越大。但我们还需要保证逻辑链是
成立的，所以引入约束就不可避免。我们是在这个两难之中选一个平衡。这时你把下层设
计暴露到高层设计中，这个东西就影响我们对这个逻辑链的优化。也许只有一两个的时候
我们还能脑补把它忽略掉，但这种东西稍一多，人脑的处理能力有限，它的影响我们对问
题的判断了。

所以，构架设计如此关注所谓的“关联”，当一个逻辑修改的时候，它会影响其他逻辑，我
们就说他们有关联，有多个关联的东西，才值得放在同一层的逻辑里面讨论。

比如下面这个设计：

        .. figure:: _static/配置文件关联.svg

在例1中，配置文件和每个模块都有关联，我们对配置文件的要求就很高，在高层逻辑里，
我们必须很小心推演一下配置文件应该用什么方案比较好。

而在例2中，配置文件只和testbench发生关联，再转化为testbench对sysinit和testcase
的要求。这时，配置文件的格式在高层设计中就不是个大不了的问题了。因为只要我们推
演好testbench和sysinit/testcase两个模块的关系，这个约束是自然会发生的，配置文件
格式怎么变化，都改变不了这个高层逻辑，我们就可以把这个逻辑留给testbench的内部分
析去做。我们先分析好testcase, testbench和sysinit之间的关系，以及它们是不是可以
实现我们的设计目标，有没有更好的方法，这才是最重要的。否则，你就会陷入格式这个
细节问题上，丢弃了高层逻辑的设计工作了。换句话说，你的构架设计，没有起到保护细
节设计的作用，变成细节设计本身了。

当然，我们分析testcase-testbench-sysinit这个高层关系的时候，会涉及到这个
testbench是否可以被实现，实现风险是否大的问题。我们有可能会需要分析一下配置文件
应该怎么做的问题。但这个分析的目的仍是为了证明我们高层设计的可行性，它和我们放
下心来，觉得高层设计已经通了，专门去讨论在高层逻辑的约束下，下一层设计怎么做这
个问题无关。

外延
====

上面这个定义，拉高一个层次去思考会很有趣，可以让我们进一步贴近架构设计的本质。

架构设计是设计一组约束（限制）。那么，什么东西会成为下一层的约束，什么东西需要
成为下一层的约束呢？毕竟如果我们最后把软件开发出来，每个约束都是约束，并没有什
么不同，为什么有些约束就会被我们作为高层约束来引入，必须被我们作为下一层的约束
来引入呢？

我认为，这和人思考模型有关。我在这里讨论过这个问题（说明：本文的链接，都不在本
层逻辑链中，读者可以在读完全文后，有兴趣再去看）：

        :doc:`../道德经直译/活性的本质`

没有人介入控制的时候，外部事物是直接被它的物理属性所左右的，呈现出一个“没有什么
规律”的感觉。好比雪花落入大地，堆高了会掉下来，平了会被新的雪花破坏变得不平。当
智慧生物（包括人）介入控制的时候，智慧生物需要降低被控制对象的信息熵，所以，蜂
巢会挂到树上，人类的房子会变得规则。因为智慧本质是在抽象，是构成可以重复的
Pattern，这样，更复杂的控制只需要是这些Pattern的重复，而不需要浪费过多的脑力资
源（也就是保证低熵），这个问题我在这里讨论过：

        :doc:`设计的减熵原理`

我们制造高层限制，就是为了人为地降低信息熵。我们无意识地从深圳走路去北京，在路
上遇到问题解决问题，这整个过程不受控，你们你无法对这个过程思考什么，人脑没法建
立一个逻辑去向这个方向努力。但你拆成“打的去机场”，“坐飞机去北京”，这就可控了。
我们遇到细节障碍的时候，有一个就近的目的去管理我们的逻辑。

这个高一层的逻辑结构，就是人脑人为制造的架子，就是架构设计：

        .. figure:: _static/架构.svg

它的目的就是让我们在做细节逻辑的时候，有一个依附，在发展的时候，有一个决定如何
变化，能否变化的基础。所以，架构设计确实就是个架子，它是整个设计的逻辑的架子。
我们做这个架子的时候，“看不见”它里面的细节。

我们把部分的逻辑链整个放在一个大的，人为维护的“抽象逻辑”中，我们就可以整体控制
这个系统。我们所有的软件都做成软件包，然后给软件包以“安装”这个属性，那么无论
是驱动，Office，音乐播放器，还是编译器，都可以被“安装”了。

但为了“安装”这个抽象出来的属性，我们就需要对被抽象的底层逻辑进行约束，人为地让
它呈现这个属性，否则，每个软件有自己的逻辑，不统一到这个抽象下，那么我们就无法
统一控制它，只要这个系统复杂度一高，它就不可控制了。

所以，一开始不保证高层逻辑链按一个方向去构建，到了后期，系统已经成了混沌系统，
这时再要控制什么，就没有任何办法了。

但高层逻辑链按什么方向去构建才是可靠的呢？换句话说，人脑构建的动力是什么呢？我
们可以达成各种各样的控制，我们应该选择什么去控制呢？这就是我们的需求。

有人希望控制软件的安装，他们投钱给我们去做一个“发行版”，我们基于这个逻辑链去建
立一个控制，这个就是可靠的。你个人喜欢用C++，你建立一个控制，看怎么让所有模块都
用C++编译，这就是不可靠的。因为你付不起这钱。所以，高层逻辑的“目标”是很好确立的
，就是谁为这个目标付款。

这个道理看来很简单，但到了实际情况，还是很多人会犯错。比如我们反复讨论要统一VF
，要支持ACPI，但我们却没有人愿意去深究统一VF，支持ACPI反映出用户的什么直接利益
。我们的逻辑链就是断裂的。我们的高层逻辑控制不住整个利益的逻辑链，我们所有的细
节设计上的努力，就无人埋单。这样做出来的设计，就不会有竞争力。

没有这个高层逻辑，我根本不知道怎么去评审你的细节逻辑，因为细节逻辑不知道自己努
力的方向是什么。连坐飞机还是高铁去北京都没有确定，你和我讨论是打出租车好还是快
车好，这完全没有意义。

同样，你的网卡MAC在MAC层进行抽象还是在PHY层进行抽象的逻辑没有确定，你跟我谈
Bonding的时候MAC地址应该怎么设，我也无法判断你的逻辑。

逻辑是需要依据和目标的，无依据和目标的信息堆砌，或者只有部分依据和目标的逻辑，
毫无意义。

这样会有一个有趣的推论：没有了架构，一个软件团队会变成一个外包团队。

很多硬件使能团队就是这样的：

操作系统有人做了，为了操作系统可以维护进程，可以调度虚拟机，可以迁移应用，操作
系统团队就是有脾气的：硬件必须实现某某功能，上面的软件必须这样用我。它建立了一
个属于自己的高层逻辑链。这个逻辑链必须被保证，否则埋单的用户维护进程，调度虚拟
机这个目的就不会得到满足。

硬件也有自己的高层逻辑链，比如投片费用是有限的，可以用的工艺是有条件的，要符合
某某要求软件只能如此这般才能用我。要保证能投片，你必须满足我如何高层逻辑。

但使能团队就可能没有逻辑链了：啊，操作系统要我这样啊，我看看细节上能不能满足吧
，噢，硬件接口要我这样啊，我看看细节上能不能做到吧。这样，做高层判断的时候，这
个使能团队的话是不需要听的，因为你都是就是论事的而已。就好比从深圳到北京的故事
中，一个提行李的跟班，坐飞机还是高铁，其实都不太有所谓，到时别提不动行李就行。
他不在高层逻辑中，不是高层逻辑的控制要素。

所以，一个设计团队要能持续发展，没有架构是不行的，而要有架构，就需要有自己的利
益链，整个高层逻辑中，必须有你在保障的客户利益。而且你的保障逻辑链必须是在所有
解决方案中是有竞争力的，否则你会被整体替换。成为资源团队，是把自己的整体替换可
能性放到最大。

而全局的控制者，也不会希望这样的团队成为组织主流，因为这样的结果就是整个系统越
加的不可控。大部分地方都是不平滑的表面，信息熵极高，系统就不可控了。

建议
====
前面我又定义了一次架构设计的本质，但其实我想提的建议不是前面的这些。只是我要说
一个操作建议，我需要把高层逻辑建稳了，我谈的细节才有根基，否则说了也是白说。

我想提的建议是：我期望的架构设计，很多时候，只需要几页的文档就可以描述清楚（但
工作量很可能不是不动脑写两三页文本那么大）。特别是很多特性一级的架构设计，你能
搞清楚你的开发视图就够了。我宁愿你搞完这个高层逻辑，有时间马上投下去给细节设计
设计一个逻辑，或者赶紧开始写用户手册，也别怕自己只写两三页显得不够高大上，而故
意给我弄一大堆的细节出来。你担心一下你后面直接依靠设定的标准，细节会走偏，比你
多写点字靠谱得多。把可以变化的细节逻辑变成高层的约束，这会让整个系统的逻辑失去
活性，哪里都该不动，那你就不是在做架构了，你是在自缚手脚，你还不如别做这个设计
呢。混沌至少还能用，锁死自己那是直接自杀——虽然大部分时候实现团队不会那么蠢，他
们会忽略你的设计，但我也浪费时间了呀。

