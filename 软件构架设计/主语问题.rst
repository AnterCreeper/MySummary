.. Kenneth Lee 版权所有 2020

:Authors: Kenneth Lee
:Version: 1.0

主语和宾语问题
*********************

很多工程师写设计，特别是架构设计描述的空间很容易乱，很多时候是对自己描述的东西
的主语和宾语没有清晰的认识。本文专门讨论一下这个问题。

我们还是通过具体例子来帮助建立抽象的概念。

先看这样一个设计：我们在CPU（令为C）中加了一个协处理器（令为A），A内部也有异步
于C的执行逻辑，有自己的寄存器，我们在程序中增加控制接口去控制这个A的行为。

细节我们慢慢加，我现在先问个问题：下面这个对A的工作上下文描述正确吗？

        .. figure:: _static/一个协处理器上下文的例子.svg

当然不正确了，因为指令的主语是软件，是CPU提供给软件的接口，这个上下文正确的表
述应该是这样的：

        .. figure:: _static/一个协处理器上下文的例子2.svg

你是不是觉得这其实差不多？也就是个说辞而已。但这两个不同的建模，带来的是我们推
演逻辑完全的不同。

如果我们直接看到，协处理器指令是一种CPU指令，那么，对CPU指令的所有约束，也对协
处理器指令成立。这些约束包括而不限于：对指令顺序依赖，原子性，特权级，异常处理
，中断响应的行为，也同时生效。我们推那个\ doc:`逻辑闭包`\ 中每条指令的行为的时
候，就要对这些东西进行推演，而不是前一个定义那个模模糊糊的状态。

我们找一个程序看看：

.. code-block:: python

   def do_some_work():
     c_a = c_prepare_a()
     c_b = c_prepare_b()
     a_handle_a(c_a) = {
        buffer[0] = c_a
        a_step1()
        a_step2()
        a_step3()
        a_step4()
     }
     a_handle_b(c_a, c_b)
     c_wait(cond)
     a_notify(cond)

我这里，c开头的指令，是CPU执行的，a开头的指令是协处理器执行的，a_handle_a是CPU
发了一个请求，但在A上是多个step，那么这些个step在执行的时候，a_handle_b能不能
发出？a_handle_b发出的时候，c_wait能不能发出？

你不给出主语或者宾语，这简直不知道怎么才能描述得清楚。主语给你提供了这个被指向
的实体可以承受的所有可能的刺激，是我们进行状态机穷举的基础。指令作用在C上，C就
会呈现一个状态机行为，而这些指令作用在A上，A会呈现另一个状态机行为，虽然两者都
会有互相影响，但你讨论其中一个的时候，我们会有这个对象的状态可能性全集，这个全
集就是不同的。比如C进行复位的时候，A会复位吗？反过来呢？两者不是一个对象，它们
的初始行为就是不同的，A在做stepX的时候，C收到中断，这个状态机行为又该是什么样
的呢？中断是C状态机所有可能性的一部分。但它不是A所有状态机行为的一部分，我们完
全可以在C中处理着中断，让A继续它的step1, step2……你把两者看作一个对象还是两个对
象，这个细节处理就会有很大差别。因为状态机这种东西，你只要有过几次实际经验，就
会知道，你有机会在任何一个状态上多漏进去一个激励，它的变化就可以是double上升的
。

所以，分不清楚对象，和什么行为能对这个对象进行刺激，也别谈什么状态机了。

让我们把问题再提高一级复杂度，我们把A的行为封装成一个函数，
函数里面执行的是A的step1/step2这些指令，而C调用这个函数使用C的A控制指令。在C调
用A后，C暂时成为A的代理，处理A的异常退出和访存要求。C和A的代码分别需要不同的编
译器进行编译：

        .. figure:: _static/一个协处理器上下文的例子3.svg

我们这里有好多分离的对象：

1. A的函数

2. C的函数

3. C

4. A

不考虑系统中的不同对象，我看到有些人会这样描述这个系统：

C先调用load_a_app()指令，把A的代码加载到A中，然后再调用exec_a()，让A进入执行状
态，C停在exec_a()上，如果A发生内存访问，就用自己的内存处理单元（LSU）为C进行内
存访问，如果内存缺页，就进入异常处理向量，进行缺页处理，然后返回A继续执行。

这东西啊，你把它看作是个\ :doc:`../道德经直译/恍惚`\ 你还觉得它写得挺详细的。
你正经要用这东西写代码，你就会发现你根本不知道它在说啥。我写A的函数的时候，我
只关心我要完成的工作，我需要的是这些指令图灵完备性，我要知道的是我的入口在哪里
，能不能调用函数，我能不能反过来调用实现在C一侧的函数，在我执行的过程中，C有可
能对我发出什么控制每个这种控制我应该如何响应。比如对于A的函数，我可能可以推演
一个这样的程序模型是否可以被支持：

.. code-block:: python

   def a_entry(a_input):
     a_inst1()
     a_inst2()
     a_inst3()
     a_inst4()
     other_function()
     return result

   def other_function()
     ...

   def event(c_event):
     case c_event:
     on event1:
       ...
     on event2:
       ...

我考量这个对象的时候，我关心的是我能否获得我的输入，有没有地方给出输出，中间能
做什么行为……这样我才能封闭我针对这个对象的闭包。并形成在整个系统中我对别人的要
求。

然后我分析C的程序空间呢，我考量的是这样一个程序模型：

.. code-block:: python

   def c_call_a(a_input, a_app):
     c_load_a_app(a_app)
     c_load_a_input(a_input)
     c_call_a()                 #hold until finish
     return c_load_a_result()

   def c_fault_on_a(where, fault_type):
     case fault_type:
     on page_fault:
       load_miss_page()
     on sys_error:
       report_error()
       exit()

这个模型我关心的是我能否把程序，参数，调用等信息传进去，我还关心出了缺页或者其
他异常的时候，是否每种情况我的程序都是受控的。
     
而C呢？我们关心的是这些所有外部刺激对我们的要求，我们先要找到所有的激发源：

        .. figure:: _static/一个协处理器上下文的例子4.svg

剩下的问题是我们的所有承诺的行为，它的状态机是否都能保证满足。

然后我们可以把一样的方法用于A这个硬件。

你不去明确给定一个一个独立的对象，专门完整分析这个对象的行为，给出一个上帝视角
的过程，这就不是一个完整的设计，你说它对还是不对，都没法校验。

.. vim: set tw=78:
