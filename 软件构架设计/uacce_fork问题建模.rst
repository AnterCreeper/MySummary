.. Kenneth Lee 版权所有 2021

:Authors: Kenneth Lee
:Version: 1.0
:Date: 2021-11-12
:Status: Draft

Uacce fork问题建模
******************

介绍
====

本文就是简单推演一下Uacce fork特性怎么做的问题，但我每个公共的设计都想当作一个
架构设计的案例来用，所以就写到这里来的。我尽量让架构方面的讨论独立，放在下面这
样的批注里面：

.. note::

  这是架构方面考量的批注。

不关心架构设计方法论，只关心解决方案的读者跳过这些批注就可以了。

技术背景
========

Uacce是我们在Linux内核中放的一个用户态加速器的框架，它其实就解决一个问题：让用
户态可以不用经过系统调用访问加速器。

但这个问题立即会衍生一个问题：如果用户态不需要经过系统调用访问加速器，那么我们
就必须让用户态直接和设备空间通讯，我们需要把IO空间暴露给用户态。这通常是MMIO。

当然如果我们做了一组可以控制的IO指令，我们也可以基于这组IO指令做这种控制，这种
东西等到MMIO不合时宜的时候我们可以再加功能。不过，x86的IO指令是没戏了，这组指令
就只允许内核态访问。

另外，反过来，加速器如果用到内存，这个内存也必须在进程的范围内，不能超出这个范
围。这有两种方法，一种是为加速器特别分配内存，然后映射到进程空间。这不那么灵活，
我们选择的是另一个方案：让进程和加速器共用一样的页表，这样，进程看到的空间，和
加速器看到的内存空间，就是完全一样的了。

这个功能已经以uacce这个名字上传到5.10主线了，它强依赖于IOMMU的sva特性，或者可以
说它很大程度上推动着sva特性的发展，因为它是sva特性实际的第一个商用的用户。SVA特
性其实改变了很多用户态进程的概念，所以，它其实很多设计方向还没有最终确定，本文
现在要讨论的，就是其中一个很重要的方向。

这个方向是这样的：如果一个进程打开一个uacce句柄，map了它的mmio和共享内存空间（
在uacce中称为dus空间，通常用于放加速器的内存静态配置数据），正在使用的时候，如
果我们fork了一个子进程，内核的行为应该是什么？

.. note::

  很多工程师不愿意在推演一个特性之前重新定义问题的范围。他们觉得：这不是都知道
  吗？问题是，你在写一个复杂函数前，有本事不列出所有的参数（包括可以使用的全局
  变量，可以调用的函数），写好这个复杂函数吗？有某个参数，有某个数据关联关系，
  直接改变你的算法。所以，把问题的范围明确表述出来，有助于我们在一个封闭的逻辑
  空间里面反复找到我们解决方案（算法）的机会点，没有这样的东西，你就会跟着“惯例
  ”走，这样你创新不了任何东西，也解决不了大部分的问题。

  这恰恰就是进行架构设计最主要的作用，我们需要在无数的可能性中，找到一条最有优
  势的路，这个选择错过了，等你的细节都上去以后，你就没有选择了。

逻辑空间分析
============

uacce加速加速器可以服务多个进程，每打开一次uacce文件，需要为加速器和进程建立一
个上下文，这个关系用类图可以这样表达：

.. figure:: _static/uacce_fork1.svg

在这个关系中，file和queue（以下简称q）就是这个上下文的实体，每次打开一个文件，
就建立一个上下文，这个上下文记住了进程的MM，同时也记住了加速器为这个上下文建立
的资源。这个关系只在进程和file之间是1-\*的关系，也就是q和mm是\*-1的关系，只要
能保证mm更新的时候可以通知到每个q，就不会有其他的问题。

现在我们考虑fork的情形。为了简化逻辑，我们把mm放到进程里，把uacce_dev忽略掉，把
这个图表述成这样：

.. figure:: _static/uacce_fork2.svg

这种情况，设备会在一个上下文中服务两个独立的用户，破坏了我们原来的语义。一个最
简单的逻辑是：我们要求用户态重新初始化，关闭这个文件，不拷贝qfr，这样这个问题就
没有了，这个问题看起来并非不可接受，我们只是要求程序这样写：

.. code-block:: python

  def father_process():
    ctx = init_uacce_dev(...)
    pid = fork()
    if (pid == 0)
      ctx = reinit_uacce_dev(ctx)
    use_usacce_dev(ctx)

这个程序没有变得特别复杂，reinit_uacce_dev()只有一点点工作量：只要在
init_uacce_dev()的时候记录所有的初始化参数，reinit的时候关闭老文件，根据参数重
新映射空间，看来都挺正常的。

.. note::

  你看，最初我们构想这个需求的时候，想的是要内核中做，我们猜想在用户态做成本非常高，
  很多问题都解决不了，但实际上不是这样。我们完全可以退回到这个方案上，所以说，需求
  分析其实非常必要。需求分析也不是一些人想象的：”这是领导（客户）要求的，我们只
  能这样做。”需求方只是要解决问题而已，不是自己有解决方案啊。

如果把这个复制的工作放到内核中，会不会让问题变得更简单？由于fork的时候内核不会
复制file，我们要保证两个进程各自有自己的上下文，就要分配一个新的queue给子进程。
原来map过qfr的位置要全部重新映射一个新的空间，让程序变成这样：

.. figure:: _static/uacce_fork3.svg

这可能有三个地方会出问题：

1. 时机：什么时候施行这个重新分配

2. 如何保证原来映射的qfr还在原来的位置上？

3. 如何保证子进程的mm可以绑定到新的queue上？

首先考虑时机。从“大道理”上说，我现在创建了一个新进程，原来的进程打开了一个设备
，我希望在这个设备上分配一个新上下文给这个文件。但一旦分配新的上下文了，这个
file就不是那个file了，这说起来是一个使用相同fd的新file。那我觉得合理的分配方法
是在dup_fd的时候，给file一个新的属性（比如叫DEV_WITH_CTX），这样，就不要在
dup_fd的时候做get_file了，直接调用对应设备的clone回调，分配新的ctx，这一切都顺
理成章。我们自己创建了这个时机，不用像老鼠那样到处躲，因为这个需求本身也是合理
的：“已经打开的设备文件被clone，就应该clone一个新的上下文啊”）。

有了前面这个机会，重新绑定，重新映射qfr，就不是问题了。

所以，这个问题最终变成：社区是否接受DEV_WITH_CTX，如果接受，我们就加这个功能，
同时自己作为第一个用户。如果不接受，Fine，我们退回到用户态方案好了。

.. note::

  其实我提出这个观点（不表示现在选定了）前，我们已经有了很多“老鼠方案”了，我不反对
  做这些分析，但我们最终还是要回到正经的方案上来，否则我们可能挖了半天的洞，一下就
  被人推翻了，白干。而这，就是架构设计要起的作用。

总结
====

先不总结，讨论一下再说。
